\chapter{Does PTS Fulfill The Requirements of PT?}\label{ch:does-pts-fulfill-the-requirements-of-pt?}

This thesis is concerned about implementing Package Templates in TypeScript.
However, in order to determine to what degree we have actually implemented PT or just created something that looks like it, we have to understand what the requirements of PT are, and if we are meeting those requirements.
We will therefore in this chapter look at the requirements as described in~\cite{jot}.
After getting an understanding of the requirements we are going to look at how our implementation holds up to them.

\input{chapters/does-pts-fulfill-requirements/the-requirements-of-pt.tex}

\section{PTS' Implementation of the Requirements}\label{sec:pts'-implementation-of-the-requirements}

With a proper understanding of the requirements of PT we can examine our implementation and see whether our implementation fulfills these requirements.
For each requirement we will be looking at a program in PTS which showcases the requirements, and the resulting program after compilation.

\subsection{Parallel Extension}\label{subsec:pts-parallel-extension}

In order for our implementation to fulfill this requirement it will have to be able to reference additions to a class in another addition in the same package/template.
We can check if this is possible by creating a simple program, as seen in listing~\vref{lst:pts-parallel-extension}, and see if this results in a valid TypeScript program with the intended semantics and correct bindings.
Our PTS program consists of a template \codeword{T} with two classes \codeword{A} and \codeword{B}, and a package \codeword{P} which makes additions to both classes.
The addition to class \codeword{A} simply adds another field, \codeword{j}, to the class, while the addition to class \codeword{B} adds a method to the class which references both the old attribute of class \codeword{A} as well as the new addition.
The program successfully compiles, and the resulting TypeScript program can be seen at the bottom of the listing.

\begin{code}{typescript}{A program showcasing parallel extension in PTS, and the resulting program in TypeScript at the bottom.}{lst:pts-parallel-extension}
    // PTS
    template T {
        class A {
            i = 1;
        }

        class B {
            a = new A();
            x = 1;
        }
    }

    pack P {
        inst T;
        addto A {
            j = 1;
        }

        addto B {
            function f() {
                return this.a.i + this.a.j;
            }
        }
    }

    // Resulting program
    class A {
        i = 1;
        j = 1;
    }

    class B {
        a = new A();
        x = 1;
        function f() {
            return this.a.i + this.a.j;
        }
    }
\end{code}

Now we see that it does work for the program above, so it would seem that the basic mechanism for parallel extensions does work.
However, to be completely certain that it will work for all programs we are going to have to investigate this a bit further.
To understand how this requirement can be fulfilled it is important to understand how the requirement could fail to be fulfilled.
A failure to fulfill the requirement would be that making additions in parallel would fail to compile.
Given a syntactically legal program the only ways for this to fail during compilation would be due to a semantic error.
The legal reasons for an addition to fail would be if we are trying to make additions to a class which doesn't exist, or if we are trying to reference attributes in a class that does not exist.
Both of these should fail, and in our compiler will fail.

The first legal reason where our compiler should fail is when we are making additions to a non-existent class.
This will be caught in the class merging part of our compiler.
In the class merging part of the implementation the compiler will group all classes and additions by name.
If there is a group with only additions then it will fail, as there is no class to make additions to.

The second legal reason is when we are trying to reference non-existent attributes in a class.
An example of this can be seen in listing~\vref{lst:pts-parallel-extension-non-existent-attribute}.
This example will fail during the type-checking of our pacakges/templates, as discussed in~\vref{sec:type-checking-of-templates}.
Instead of trying to examine the class \codeword{A} for an attribute \codeword{h}, and maybe not finding it as it might be in a later instantiation, we will assume that the addition is valid and perform the addition to the class.
When we later have performed any further instantiations and additions we will run a type-check on the templates/packages which will pick the error up.

\begin{code}{typescript}{An example showing a program that should fail during compilation, where we are trying to reference a non-existent attribute, \codeword{h}, in an addition to class \codeword{A}.}{lst:pts-parallel-extension-non-existent-attribute}
    template T {
        class A {
            function f() {
                return 1;
            }
        }
    }

    package P {
        inst T;
        addto A {
            function g() {
                this.h();
            }
        }
    }
\end{code}

Now that we understand when it should fail lets look at some scenarios where it should not fail.
We do not want it to fail compilation if we have a valid parallel extension.
One such way it could fail is if we tried to check if the addition contains any invalid references or type errors.
This could commonly happen if we are trying to check the addition's references to the declared class.
However if not implemented properly this might fail as there might be several declarations that are going to be merged, including additions.
As we discussed previously we are avoiding this from happening by assuming that the addition is valid, and waiting until all merging has been performed and then type-checking the program afterwards.
This has the downside of making it harder to give meaningful error messages when an error is made by the programmer, however we can assure ourselves that we do not wrongly fail compilation.

\subsection{Hierarchy Preserveration}

In order to fulfill the hierarchy preservation requirement we have to preserve all super-/subclass relations after additions and merges have been applied.
Listing~\vref{lst:pts-hierarchy-preservation} shows a program, and the resulting TypeScript program after compilation, which fulfills the requirement of hierarchy preservation.
This one example certainly fulfills the requirement as class \codeword{B} is still a subclass to class \codeword{A} after both a merge and an addition is made to \codeword{B}.
As we talked about briefly in section~\vref{subsec:merging-class-declarations} when we merge classes we make sure to also merge their class signatures.
This means that we might end up with instances where we are extending multiple classes, however this will then be picked up in the type-checking stage of the compiler.
If we had not merged class declarations, and just stuck with a random class declarations in the group of classes that should be merged for instance, we could have ended up breaking the inheritance hierarchy in the aforementioned listing, as we could have ended up with class \codeword{C}'s declaration, which does not have a superclass.
Because of this we can with confidence say that we have fulfilled the requirement of hierarchy preservation.

\begin{code}{typescript}{Example showcasing a program where the super-/subclass relation between classes \codeword{A} and \codeword{B} is preserved after additions and class merging have been applied. We can see the resulting TypeScript program at the bottom of the listing, where the semantics are as expected.}{lst:pts-hierarchy-preservation}
    // PTS
    template T1 {
        class A {
            i = 0;
        }

        class B extends A {
            f() {
                return this.i;
            }
        }
    }

    template T2 {
        class C {
            j = 0;
        }
    }

    package P {
        inst T1;
        inst T2 { C -> B };
        addto B {
            k = 0;
        }
    }

    // Resulting program
    class A {
        i = 0;
    }

    class B extends A {
        f() {
            return this.i;
        }
        j = 0;
        k = 0;
    }
\end{code}

\subsection{Renaming}

This requirement

\subsection{Multiple Uses}

In order for this requirement to be fulfilled we should be able to re-use a template several times, with different renamings and additions while the different instantiations stay independent of each other.
This was something I payed extra attention to during implementation, not just to fulfill the requirement, but to avoid bugs.
I solved this by making sure that while transforming the AST this would be done in an immutable fashion.
In order to test this we will be creating a simple program where we instantiate the same template more than once and see if the resulting program is as expected.
The program can be seen in listing~\vref{lst:pts-multiple-uses}.
The program comprises a template \codeword{T} with a single class, \codeword{A}, with an attribute \codeword{i}.
This template will then be instantiated three times, where we first will be renaming the class and field, then instantiate without renaming, and finally instantiate it with just an attribute renaming.
The expected program should have two classes, one class \codeword{B}, with an attribute \codeword{j}, and a class \codeword{A} where the two bottom instantiations should have created a merged class with attributes \codeword{i} and \codeword{x}.
We can see from the resulting program after a successful compilation that this is as expected.

\begin{code}{typescript}{A program showcasing multiple uses in PTS, and the resulting program in TypeScript at the bottom.}{lst:pts-multiple-uses}
    // PTS
    template T {
        class A {
            i = 0;
        }
    }

    pack P {
        inst T { A -> B (i -> j) };
        inst T;
        inst T { A -> A (i -> x) };
    }

    // Resulting program
    class B {
        j = 0;
    }

    class A {
        i = 0;
        x = 0;
    }
\end{code}

\subsection{Type Parameterization}

The type parameterization requirement is something the implementation does not fulfill.
This was not implemented due to it being down prioritized.
There is only so much time available during the span of a master thesis, and I chose to rather look at how the core of PT would fit into a structurally language like TypeScript, rather than on making sure it would be a fully fleshed out implementation of PT.
Another reason for avoiding this is that much of Type Parameterization can be achieved through merging and renaming.

% TODO kanskje vise noen eksempler p√• dette

\subsection{Class Merging}

\subsection{Collection-level Type-checking}\label{subsec:implementation-collection-level-type-checking}

