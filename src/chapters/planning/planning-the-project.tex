%! Author = Petter
%! Date = 9/22/2020

\chapter{Planning the Project}\label{ch:planning-the-project}

Before we start the implementation of our language we first need to do some planning.
We know we are going to be creating a programming language, a superset of TypeScript with the addition of Package Templates.
However, we might want to look at if creating a superset of TypeScript is the way to go, or if keeping it simple and extending JavaScript is a better call.
We might also want to see if it is needed to create a language at all, or if we are able to create a TypeScript library which can achieve the functionality of PT instead.
There are a lot of approaches we can take for implementing our language, so we will have to map out the requirements for our desired approach.
Lastly we will have to look at all the different approaches we can take, and see which approach is right for this project.

This planning phase is crucial for the success of the project, as starting off on the wrong approach for the wrong language would set us back immensely.

\section{TypeScript vs. JavaScript}\label{sec:typescript-vs-javascript}

When extending TypeScript you might be asking yourself if it is truly necessary, is it better to keep it simple and just extend JavaScript instead?
This is something we need to find out before going any further with the planning of our project.

\subsection{Type-checking Templates}\label{subsec:why-typescript-verifying-templates}

One of the requirements of PT is that it should be possible to type-check each template separately.
There is no easy way to type-check JavaScript code without executing it and looking for runtime errors.
Even if some JavaScript program successfully executes without throwing any errors, we can still not conclude that the program does not contain any type errors.
TypeScript on the other hand, with the language being statically typed, we can, at least to a much larger extent, verify if some piece of code is type safe.
Because of this trait TypeScript is the better candidate for our language.

Now it should be noted that due to TypeScripts type system being unsound one could argue that this requirement of PT is not met.
While this is true it still outperforms JavaScript on this remark, and we will later in section~\vref{subsec:implementation-collection-level-type-checking} discuss more in-depth to what extent this requirement is met.

\subsection{Renaming}\label{subsec:ts-vs-js-renaming}

Renaming is a hard task.
In order to perform a rename we will need to find the declaration and all references to this declaration and rename these.
Doing this at compile time would mean that we will have to implement a type system of sorts, since this will help us identify references.
This is also one of the reasons for why TypeScript is a better candidate than JavaScript, as TypeScript is statically typed, meaning the type of a variable is known at compile-time, while JavaScript is dynamically typed, where the type of a variable is first known at run-time.

\section{What Do We Need?}\label{sec:what-do-we-need}

There are a lot of approaches one can take when working with TypeScript, however due to the nature of this project there are some restrictions we have to abide by.
Our approach should allow the following:

\begin{itemize}
    \item The ability to add custom syntax (access to the tokenizer / parser)
    \item Enable us to do semantic analysis.
\end{itemize}

In addition to these we would also like to look for some other desirable traits for our implementation:

\begin{itemize}
    \item Loosely coupled implementation (So that new versions of typescript not necessarily breaks our implementation).
    %\item Mer? % TODO
\end{itemize}


\section{Approach}\label{sec:choosing-the-right-approach}

Before jumping into a project of this magnitude it is important to find out what approach to use. 
The goal of this project is to extend TypeScript with the Package Templates language mechanism, this could be achieved by one of the following methods:

\begin{itemize}
    \item Implementing as a library
    \item Making a preprocessor for the TypeScript compiler
    \item Making a compiler plugin/transform
    \item Making a fork of the TypeScript compiler
    \item Making a custom compiler
\end{itemize}

\input{chapters/planning/implementing-as-a-library}

\subsection{Preprocessor for the TypeScript Compiler}\label{subsec:preprocessor-for-the-typescript-compiler}

% TODO
%\red{Tenker vi må diskutere hva en preprosessor er her. Det jeg gjør i min implementasjon er nok en slags preprosessering, men jeg gjør også mer enn en typisk preprosessor. Kan vi si at en preprosessor er noe som gjør en transformasjon på kildekoden, uten "kunnskap" om det underliggende språket. Jobber bare med det som tekst? Gjør ikke noen semantisk sjekk, osv. I så fall er det ikke mulig å implementere som PP, da blant annet renaming krever en kunnskap til det underliggende språket, men instansiering kan nok gjøres gjennom PP.}
Could we implement the PT specific features in a preprocessor?
In order to understand this we need to understand what a preprocessor is.
A preprocessor is often used in combination with a compiler, where the preprocessor often prepares the source files for compilation, such as removing comments, expanding macros (such as \codeword{\#include} in C), and other smaller transformations.
One distinct difference between a preprocessor and a compiler is that the preprocessor works on the source code as a piece of text, with no knowledge of the underlying programming language, while the compiler often has knowledge about the language of the program.
This means that the compiler is able to perform more advanced tasks, such as semantic analysis.

So the question becomes, can we transform a PTS program to TypeScript by just doing textual transformations, and no semantic analysis.
We would most likely be able to implement parts of PT with a preprocessor such as simple instantiation without renaming.
However, as we mentioned in section~\vref{sec:typescript-vs-javascript} we will need to do some type-checking in order to find the correct references when renaming, we can't just rename everything that is textually equal.
This means that we will need something more advanced than a preprocessor to implement the features of PT\@.

\subsection{TypeScript Compiler Plugin/Transform}\label{subsec:typescript-compiler-plugin}

At the time of writing the official TypeScript compiler does not support compile time plugins.
The plugins for the TypeScript compiler is, as the TypeScript compiler wiki specifies, "for changing the editing experience only"~\cite{tscplugin}.
However, there are alternatives that do enable compile time plugins/transformers;

\begin{itemize}
    \item ts-loader~\cite{tsloadergithub}, for the webpack ecosystem
    \item Awesome Typescript Loader~\cite{awesometypescriptloadergithub}, for the webpack ecosystem.
    \item ts-node~\cite{tsnodegithub}, REPL/runtime
\end{itemize}

Unfortunately all of the above do not support adding custom syntax, as they only work on the AST produced by the TypeScript compiler.
Because of this they are not a viable option for our use-case and will therefore be discarded.

\subsection{Babel plugin}\label{subsec:babel-plugin}

Babel isn't strictly for TypeScript, but for JavaScript, however there does exist a plugin for TypeScript in babel, and we could write a plugin that depend on this TypeScript plugin.

Making a Babel plugin will make it very accessible as most web-projects use Babel, and the upkeep is cheap, as plugins are loosely coupled with the core.

In order for a Babel plugin to support custom syntax it has to provide a custom parser, a fork of the Babel parser.
Through this we can extend the TypeScript syntax with our syntax for PT\@.
This is all hidden away from the user, as this custom parser is a dependency of our Babel plugin.

Seeing as we have to make a fork of the parser in order to solve our problem, the upkeep will not be as cheap as first anticipated.
However, being able to have most of the logic loosely coupled with the compiler core it will still make it easier to keep updated than through a fork of the TypeScript compiler.

% TODO: Er det støttet å bruke flere plugins med forskjellige parsere?
% E.g. babel-plugin-typescript + vårt babel plugin?

\subsection{TypeScript Compiler Fork}\label{subsec:typescript-compiler-fork}

The TypeScript compiler is a monolith.
It has about 2.5 million lines of code, and therefore has a quite steep learning curve to get into.
If we were to go with this route it could prove a hard task to keep up with the TypeScript updates, as updates to the compiler \textit{might} break our implementation.
However, as we have seen, going the plugin/transform route also requires us to fork the underlying compiler and make changes to it, however with the majority of the implementation being loosely coupled it might presumably still make it easier to keep up-to-date.
That being said it will probably be a lot easier to do semantic analysis in a fork of the TypeScript compiler vs in a plugin/transform.

\subsection{Making a Custom Compiler}\label{subsec:making-a-custom-compiler}

Making a custom compiler for PTS might seem like a hard task, but let us dig deeper into what this entails.
Firstly we need to consider what the target should be.
Normally a compiler would output some sort of byte code, like Java byte code in the Java compiler.
Many compilers also produce native code.
Native code is pretty much out of the image for our implementation as we still want to stay in the same ecosystem, namely the browser.
We could possibly also produce WebAssembly byte code, however there are a lot of constructs in TypeScript/JavaScript that do not translate to WebAssembly, such as working with the DOM\@.
Since both of these are out of the picture we could either produce TypeScript or JavaScript.
Producing TypeScript is possibly the easiest way to go, as most of PTS is TypeScript.
And producing TypeScript also means that we could run the resulting program through the TypeScript compiler to produce JavaScript.

Having TypeScript as the target for our compiler also means that we can ignore most parts of the language and mainly focus on the PT specifics.
The rest of the language can be outputted pretty much as is, since our language will be a superset of TypeScript.


\section{Conclusion}\label{sec:planning-conclusion}


While it would be great to be able to implement Package Templates as an internal DSL in TypeScript, it would seem that this is not a suitable approach.
Even though we were able to modify the prototype of the classes in the templates, and effectively achieve some form of renaming, we were not able to rename the references.
This means that we won't be able to use the renaming to its fullest potential, and are thus not able to implement it as an internal DSL\@.
On top of this, while we were able to reproduce certain PT functionality such as simple instantiations and class merging, it seems to be ... % TODO hvorfor er det ikke nais

Making a TypeScript compiler plugin would seemingly also be a good approach, in the future.
As we discussed the official TypeScript compiler, nor any of its alternatives, does not have proper support for plugins that would alter the syntax of the language.
Due to this we are not able to implement the features of PT, since these would require us to add extra syntax.
At the time this makes this approach not viable, however if in the future this would be supported it might prove a good approach for doing tasks such as these.

Implementing PT into the TypeScript compiler would likely lead to the most robust implementation, however the sheer size of the TypeScript compiler makes this approach undesirable.
I fear that this approach would be too time costly for this project, and might lead to an incomplete implementation as a result of this.
A similar project has been performed by Isene in~\cite{Isene2018}, where they implemented PT in C\# by extending the Roslyn compiler.
Here Isene suggested that a project of this size was better fit for a group of two.
To avoid re-discovering this we will therefore opt to go for another approach.
As well as this an implementation of PT in the TypeScript compiler would not achieve our desired trait of having a loosely coupled implementation.
This could result in a tedious process of dealing with merge conflicts when updates to the TypeScript compiler comes out.

Creating a plugin for babel might be a good approach, however since we have to implement our grammar as part of a fork of the babel parser, this makes the approach less desirable.
As with the approach of implementing PT in a fork of the TypeScript compiler this would also lead to a tightly coupled implementation, at least for the parser part of our compiler.
If we were able to write a plugin for the parsing step of Babel this might prove a viable option, however as of now there are no plans of supporting this.

Our last approach is creating a custom compiler.
As discussed previously, if we are able to % TODO

With the planning done we can jump into the implementation.