%\section{Implementing PT as a TS library}\label{sec:implementing_pt_as_a_ts_library}
%
%In order to implement PT we need to be able to handle the following:
%
%\begin{itemize}
%    \item Defining templates
%    \item Instantiating templates
%    \item Renaming classes
%    \item Renaming class attributes
%    \item Merging classes
%\end{itemize}
%
%\subsection{Defining Templates}\label{sub:defining_templates}
%
%Templates could be defined as an ECMAScript class, where each member of the template is a static attribute.
%
%\subsection{Instantiating Templates}\label{sub:instantiating_templates}
%
%\subsection{Renaming Classes}\label{sub:renaming_classes}
%
%Since each class in a template is just a static member, we could create a new template where we use the new name for our class as the attribute name, and point to the class from the "old" template.
%
%TODO: Because of ES having open classes this could lead to unwanted side-effects.
%Might need to look into a different solution for this.
%
%\subsection{Renaming Class Attributes}\label{sub:renaming_class_attribtues}
%
%Maybe impossible?
%
%\subsection{Merging Classes}\label{sub:merging_classes}
%
%For merging of the types you would use the built-in decleration merging~\cite{declerationmerging}.
%Implementation merging is also possible because ECMAScript has open classes.
%For implementation merging you would create an empty class which has the type of the merged declarations, and then assign the fields and methods from the merging classes to this class.

% TODO Les over og se om dette er brukbart

\subsection{Implementing PT as a TS Library}\label{subsec:implementing-pt-as-a-ts-library}

One of the first approaches we need to check out is if we are able to achieve the functionality of PT, without having to create a compiler.
Creating a library would presumably be an easier task than having to create a compiler, and it would also make it easier to use, as the programmer would not have to install a compiler in order to get the PT functionality.
In order to implement PT we need to be able to handle the following:

\begin{itemize}
    \item Defining templates
    \item Renaming classes and class attributes
    \item Instantiating templates
    \item Merging classes
\end{itemize}

\subsubsection{Defining Templates}\label{subsubsec:defining-templates}

For defining templates we would like a construct that can wrap our template classes in a scope.
We will also need to be able to reference the template.
JavaScript has three options for this, an array, an object or a class.
It should however also be possible to inherit from classes in your own template, which rules out both arrays and objects, as there is no way of referencing other members during definition of the array/object.
Templates should therefore be defined as classes, where each member of the template is an attribute of the template class.
In listing~\vref{code:libraryimpl-template} we see an example of how this could be done.

%We are making the templates classes static in order to be able to rename them, see section~\vref{sub:renaming_classes}.

\codeinputfile{template-example-without-decorator.ts}{typescript}{Example of defining a template in a library implementation.}{code:libraryimpl-template}

\subsubsection{Renaming Classes and Class Attributes}\label{subsubsec:renaming-classes-and-class-attributes}

Renaming of classes is possible to an extent.
Since we made the classes static attributes of the template class we could easily just create a new static field on the template class and use the \codeword{delete}-op~\footnote{An operator in JavaScript for removing a property of an object. See~\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete}.} to remove the old field.
We can see an example of this in listing~\vref{code:libraryimpl-template-renaming}.


\codeinputfile{class-renaming-example.ts}{typescript}{Example of renaming a template class}{code:libraryimpl-template-renaming}

Even though we were able to give the class a "new name", this would still not actually rename the class.
Any reference to the old names would be left unchanged, and thus we are not able to achieve renaming in TypeScript.
Listing~\vref{lst:lib-rename-problem} shows how this can be a problem, where the function \codeword{f} of class \codeword{X} would fail at run-time due to it not being able to find class \codeword{A}.

\begin{code}{typescript}{Example showcasing the problems of renaming classes in a template in the library implementation.}{lst:lib-rename-problem}
    // Type-safe template declaration
    class T1 {
        static A = class {
            i = 0;
        }
        static X = class {
            f() {
                return new A();
            }
        }
    }

   // Renaming
    const classRef = T1.A;
    T1.B = classRef;
    delete T1.A;

    // Trying to use the template after renaming
    const x = new T1.X();
    x.f(); // ReferenceError: A is not defined
\end{code}

Attribute renaming would most likely be possible in a similar manner, where we could change the prototype~\footnote{The prototype of a class is an object which objects of the class inherit their methods from. See~\url{https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes}.} of the class.
Seeing as we are not able to fully rename classes by doing this we will not be looking further into this.

\subsubsection{Instantiating Templates}\label{subsubsec:instantiating-templates}

As with renaming, we are also able to instantiate templates to an extent.
We are able to iterate over the attributes of the template class, and populate a package/template with references to the template.
An example of this can be seen in listing~\vref{code:libraryimpl-template-inst}.

\codeinputfile{inst-template-example.ts}{typescript}{Example of instantiating a template}{code:libraryimpl-template-inst}

The instantiation will only contain references to the instantiated templates classes, while PT instantiations make textual copies of the templates content.
Only having references to the original template could mean that if a template that has been instantiated is later renamed, then the instantiated template might lose some of its references.
We could possibly avoid circumvent this by getting the textual representation of the class, through the class' \codeword{toString}, and then use \codeword{eval} to evaluate the class declaration.

\subsubsection{Merging Classes}

For merging of types you would use the built-in declaration merging~\cite{declerationmerging}.
Implementation merging is also possible because JavaScript has open classes.
For implementation merging you would create an empty class which has the type of the merged declarations, and then assign the fields and methods from the merging classes to this class.
There are several libraries that supports class merging, such as mixin-js~\cite{mixinjs}.

\subsubsection{Conclusion}

Since we are not able to support renaming fully we will not be able to implement PT as a library for TypeScript.
Because of this we will have to find another approach for the project.
