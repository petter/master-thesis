%\section{Implementing PT as a TS library}\label{sec:implementing_pt_as_a_ts_library}
%
%In order to implement PT we need to be able to handle the following:
%
%\begin{itemize}
%    \item Defining templates
%    \item Instantiating templates
%    \item Renaming classes
%    \item Renaming class attributes
%    \item Merging classes
%\end{itemize}
%
%\subsection{Defining Templates}\label{sub:defining_templates}
%
%Templates could be defined as an ECMAScript class, where each member of the template is a static attribute.
%
%\subsection{Instantiating Templates}\label{sub:instantiating_templates}
%
%\subsection{Renaming Classes}\label{sub:renaming_classes}
%
%Since each class in a template is just a static member, we could create a new template where we use the new name for our class as the attribute name, and point to the class from the "old" template.
%
%TODO: Because of ES having open classes this could lead to unwanted side-effects.
%Might need to look into a different solution for this.
%
%\subsection{Renaming Class Attributes}\label{sub:renaming_class_attribtues}
%
%Maybe impossible?
%
%\subsection{Merging Classes}\label{sub:merging_classes}
%
%For merging of the types you would use the built-in decleration merging~\cite{declerationmerging}.
%Implementation merging is also possible because ECMAScript has open classes.
%For implementation merging you would create an empty class which has the type of the merged declarations, and then assign the fields and methods from the merging classes to this class.

% TODO Les over og se om dette er brukbart

\subsection{Implementing PT as a TS Library}\label{subsec:implementing-pt-as-a-ts-library}

In order to implement PT we need to be able to handle the following:

\begin{itemize}
    \item Defining templates
    \item Renaming classes and class attributes
    \item Instantiating templates
    \item Merging classes
\end{itemize}

\subsubsection{Defining Templates}\label{subsubsec:defining-templates}

For defining templates we would like a construct that can wrap our template classes in a scope.
We will also need to be able to reference the template.
ECMAScript has three options for this, an array, an object or a class.
It should however also be possible to inherit from classes in your own template, which pretty much rules out both arrays and objects, as there is no way of referencing other members during definition of the array/object.
Templates could there be defined as ECMAScript classes, where each member of the template is a static attribute of the template.
In listing~\vref{code:libraryimpl-template} we see an example of how this could be done.

We are making the templates classes static in order to be able to rename them, see section~\vref{sub:renaming_classes}.

\codeinputfile{template-example-without-decorator.ts}{typescript}{Example of defining a template}{code:libraryimpl-template}

\subsubsection{Renaming Classes and Class Attributes}\label{subsubsec:renaming-classes-and-class-attributes}

Renaming of classes is possible to an extent.
Since we made the classes static attributes of the template class we could easily just create a new static field on the template class (with decleration merging to get the correct type for the new name) and \codeword{delete}\cite{deleteop} the old field.
We can see an example of this in listing~\vref{code:libraryimpl-template-renaming}.

\codeinputfile{class-renaming-example.ts}{typescript}{Example of renaming a template class}{code:libraryimpl-template-renaming}

Even though we were able to give the class a "new name", this would still not actually rename the class.
Any reference to the old names would be left unchanged, and thus we are not able to achieve renaming in TypeScript.

\subsubsection{Instantiating Templates}\label{subsubsec:instantiating-templates}

As with renaming, we are also able to instantiate templates to an extent.
We are able to iterate over the attributes of the template class, and populate a package/template with references to the template.
An example of this can be seen in listing~\vref{code:libraryimpl-template-inst}.

\codeinputfile{inst-template-example.ts}{typescript}{Example of instantiating a template}{code:libraryimpl-template-inst}

The instantiation will only contain references to the instantiated templates classes, while PT instantiations make textual copies of the templates content.
Only having references to the original template could mean that if a template that has been instantiated is later renamed, then the instantiated template might lose some of its references.


\subsubsection{Merging Classes}

For merging of types you would use the built-in declaration merging~\cite{declerationmerging}.
Implementation merging is also possible because ECMAScript has open classes.
For implementation merging you would create an empty class which has the type of the merged declarations, and then assign the fields and methods from the merging classes to this class.
There are several libraries that supports class merging, such as mixin-js~\cite{mixinjs}.

\subsubsection{Conclusion}

Since we are not able to support renaming and instantiations we can conclude that Package Templates can not be implemented as a library in TypeScript, we will need to implement this as part of a compiler.
