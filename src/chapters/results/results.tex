\chapter{Results}\label{ch:results}

\section{How Can PTS Be Used?}\label{sec:how-can-this-be-used?}

There are mainly two ways of using the PTS compiler:

\begin{itemize}
    \item Installing it globally, or
    \item Creating a PTS project
\end{itemize}

In the following sections we will look at how you can use install and use it for both approaches.

The PTS compiler requires you to have Node and NPM installed on your computer.

\subsection{Installing and Using PTS Globally}\label{subsec:installing-and-using-pts-globally}

Installing PTS globally will enable you to use PTS anywhere, and might be favorable if you are planning to create several smaller projects to test it out, or if you are not too experienced with the node ecosystem.
If you want to install the compiler globally you can do the following:

\begin{minted}{bash}
    $ npm install -g pts-lang
\end{minted}

This will give you access to the PTS compiler CLI through the command \codeword{pts-lang}.
By not specifying any command line arguments you get a helpful text describing how to use the compiler:

\begin{minted}{text}
$ pts-lang
Options:
      --help                      Show help                        [boolean]
      --version                   Show version number              [boolean]
  -i, --input                     Name of the input file [string] [required]
  -o, --output                    Name of the output file           [string]
  -v, --verbose                   Show extra information during
                                  transpilation                    [boolean]
  -t, --targetLanguage, --target  Target language of the transpiler
                                       [choices: "js", "ts"] [default: "js"]
  -r, --run                            [boolean] [required] [default: false]

Missing required argument: input
\end{minted}

\subsection{Creating a PTS Project}\label{subsec:creating-a-pts-project}

If you are using PTS for a specific project it might be better to set it up as a project dependency in npm.
When installed in a npm project the CLI is available to use through npm scripts or through accessing it directly from the \codeword{node\_modules} folder in your project.
The compiler can also be access through the API by importing it as with any other npm package.

Installing it inside a npm project will not require you to install it globally, as it will stay contained in the project.
This also means that any contributors of the project will not have to worry about installing PTS, as it will be installed when the project is set up.

To initialize an NPM project you can do the following:

\begin{minted}{bash}
    $ mkdir <project name>
    $ cd <project name>
    $ npm init -y
\end{minted}

With a project set up you can install the PTS compiler as following:

\begin{minted}{bash}
    $ npm install pts-lang
\end{minted}

With the PTS compiler installed in the project you can then set up some scripts to start and/or build the project.
This can be done by adding scripts to the project's \codeword{package.json}.
Below you can see an example of a section of a \codeword{package.json} file with scripts for running and building a file:

\begin{minted}{json}
    {
      "scripts": {
        "start": "pts-lang -i src/index.pts --run",
        "build": "pts-lang -i src/index.pts -o build/index"
      }
    }
\end{minted}

The start script only runs the program, and does not emit any files, while the build script transpiles the \codeword{src/index.pts} file to JavaScript.
If you would rather have TypeScript output you can use the \codeword{-t} flag to specify this:

\begin{minted}{bash}
    pts-lang -i src/index.pts -o build/index -t ts
\end{minted}

\subsection{A Real World Example}\label{subsec:a-real-world-example}

Now that we understand how to get PTS set up, let us look at how it can be used in a real world example, and how this enables the programmer to modularize the code base even further giving great flexibility.

The most common use of TypeScript is to create web applications.
Let us look at how PTS can help make this task easier for the programmer.
We will try to create a simple web application for displaying a Pokémon.
To do this we will use one of the most popular web frameworks, React.

React is a web framework developed by Facebook.
It makes creating scalable web projects easier to handle, through enabling the programmer to modularize collections of elements into "components".
These components are often created to make reuse of common elements easier, such as creating a styled button with certain features, or we could create a component to represent the entire web application.

Displaying one specific Pokémon can be pretty simple, however we would like to create a React component that can display information and a picture of any Pokémon.
We do not want to have to write down information about all Pokémon, so we will fetch this information from an API, more specifically the PokéAPI (\url{https://pokeapi.co/}).
This API lets us fetch data from all Pokémon.

We will start of with the task of fetching data.
As this is something you commonly want to do in web applications it might be a good idea to separate this logic into a separate template:

\begin{minted}{typescript}
    template FetchJSON {
        class FetchJSON extends Component {
            componentDidMount() {
                fetch(this.props.url)
                    .then(response => response.json())
                    .then(data =>
                        this.setState(state => ({...state, data}))
                    ).catch(error =>
                        this.setState(state => ({...state, error}))
                    );
            }
        }
    }
\end{minted}

The component we see above will fetch whatever URL we pass to it in its props and update the state with the results of the fetch.
If we for some reason should fail to fetch the data we will instead update the state with the error message we got.

In addition to fetching data, it might be useful to have a logger, which will log all state changes to the console.
This is often useful when working with React components as we are able to see when they update, and what the state was at the time of the update.
Such a logger could then also be separated into its own template, like the following:

\begin{minted}{typescript}
    template StateLogger {
        class StateLogger extends Component {
            componentDidUpdate() {
                console.log("State updated!", this.state);
            }
        }
    }
\end{minted}

Finally we would like to combine these into our Pokémon component, and add some logic for displaying the information.
We will do this inside of a package, so that this will produce an output:

\begin{minted}{typescript}
    pack Pokemon {
        inst FetchJson { FetchJson -> Pokemon };
        inst StateLogger { StateLogger -> Pokemon };
        addto Pokemon {
            render() {
                if(this.state.error) {
                    return (
                        <div>
                            <h1>An error occurred</h1>
                            <p>{this.state.error.message}</p>
                        </div>
                    );
                }

                if(this.state.data === undefined) {
                    return 'Loading...';
                }

                const name = this.state.data.name;
                const pokemonTypes = this.state.data.types;
                const image = this.state.data.sprites.front_default;
                return (
                    <div>
                        <img src={image} />
                        <h1>{name}</h1>

                        <h2>Types</h2>
                        <ul>
                            {pokemonTypes.map(pokemonType => (
                                <li>{pokemonType.name}</li>
                            ))}
                        </ul>
                    </div>
                )
            }
        }

    }
\end{minted}

We could then use our Pokémon component in our application by supplying a URL for the Pokémon to display, as seen below:

\begin{minted}{typescript}
    class App extends Component {
        render() {
            <Pokemon
                url="https://pokeapi.co/api/v2/pokemon/ditto" />
        }
    }
\end{minted}

\section{In Retrospect}\label{sec:in-retrospect}

\subsection{Approach}\label{subsec:result-approach}

While we were able to implement most of PT with our approach, I fear that further development to reach a complete implementation might be hindered by our chosen approach.
This is largely because we might have to implement much of the type system in order to properly identify references.
Instead of re-inventing the wheel, we might be better off by implementing PT in a fork of the TypeScript compiler.
While this \textit{might} make updates harder, than with our implementation, we will most often likely be able to merge the changes to the TypeScript compiler into our fork with the help of Git.
Greater changes to the language might of course still give us some merge conflicts, however these larger changes could as easily make our currently used approach break.

\section{Addressing Research Questions}\label{sec:adressing-research-questions}


\subsubsection{RQ1: How does the language mechanism Package Templates fit into TypeScript and the web ecosystem?}



\subsubsection{RQ2: Does structural typing change how the core of Package Templates works?}

Most of the functionality of Package Template stay the same in a structurally typed language as they do in a nominally typed language.
The most notable deviation is the renaming mechanism.
While we still rename all valid references, it is worth noting that what a reference is will differ in a structurally typed language.

In nominal PT, all variables that are instantiated with an object of a class, will also have some explicit relation to the class.
A variable in nominal PT will likely have either the class (or a superclass) as the type, or an interface.
For the case of the variable having the class as the type the relation to itself is obviously there.
For interface or superclass as the type the relation must explicitly be declared in the class' heritage.
If the class' attributes are renamed we will either be able to rename the variables references to these attributes if the renaming was applied to the class or any of its superclasses, or at least give a detailed error message for when the renaming was applied to the interface.

In structural PT, variables instantiated with an object of a class might not have the same explicit relation to the constructed class.
A variable in a structurally typed language might be typed with a structure that the class conforms to.
However, this conformity might break after a renaming has been applied to the class.
In these cases we will not be able to rename the variables type, nor any of the variables references to the possibly renamed attributes, since these do not have the same explicit relation to the class.

\subsubsection{RQ3: Will having PT in a structurally typed language have any notable benefits over having it in a nominally typed language?}

As we discussed in section~\vref{subsec:which-better-fits-pt?} there are some benefits of hosting PT in a structurally typed language.
Structural typing does fit nicely in with the theme of Package Templates, namely re-use.
A structural type system gives the programmer a flexibility that nominal type systems can not offer to the same extent.
One of the strongest points for structural typing is how it enables us to easily use third-party libraries without necessarily having to alter our classes.
Say we have implemented a graph library in PT and later on wanted to use some third-party graph utility library.
This library might take a graph as input and do some calculations such as finding the shortest path between nodes in the graph.
In structural typing, as long as our graph implementation is structurally equal to the type of the input we can pass it with no problems.
In a nominally typed language we might have to alter our implementation to explicitly declare that our classes implement some interfaces from the library.
It might at worst not even be possible if the graph utility library has typed their input with classes instead of interfaces.
This is of course one of the strengths of PT in the first place, being able to add implementing interfaces to a class without altering the original implementation or merging classes if possible, however the fact that we would not have to perform this step in a structurally typed language could arguably be seen as a benefit.

\section{Conclusion}\label{sec:result-conclusion}


% Hva har vi gjort?

\section{Future Work}\label{sec:future-work}

\subsection{Diamond Problem}\label{subsec:diamond-problem}

essay

\subsection{Improve the Compilers Error Messages}\label{subsec:compiler-with-focus-on-error-messages}

As I mentioned shortly in subsection~\vref{subsec:the-ast-nodes} tree-sitter does have support for giving position of a syntax node, and this could be utilized to produce better error messages.
