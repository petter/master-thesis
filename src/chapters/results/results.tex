\chapter{Results}\label{ch:results}

\section{How Can PTS Be Used?}\label{sec:how-can-this-be-used?}

\subsection{Creating a PTS Project}\label{subsec:creating-a-pts-project}

In order to use the PTS compiler you will need to have node and npm installed on your computer.

If you want to install the compiler globally you can do the following:

\begin{minted}{bash}
    $ npm install -g pts-lang
\end{minted}

This will give you access to the PTS compiler CLI through the command \codeword{pts-lang}.
By not specifying any command line arguments you get a helpful text describing how to use the compiler;

\begin{minted}{text}
$ pts-lang
Options:
      --help                      Show help                        [boolean]
      --version                   Show version number              [boolean]
  -i, --input                     Name of the input file [string] [required]
  -o, --output                    Name of the output file           [string]
  -v, --verbose                   Show extra information during
                                  transpilation                    [boolean]
  -t, --targetLanguage, --target  Target language of the transpiler
                                       [choices: "js", "ts"] [default: "js"]
  -r, --run                            [boolean] [required] [default: false]

Missing required argument: input
\end{minted}

If you are using PTS for a specific project it might be better to set it up as a project dependency in npm.
This will not require you to install it globally, it will stay contained in the npm project.

Initialize the project:

\begin{minted}{bash}
    $ mkdir <project name>
    $ cd <project name>
    $ npm init -y
    $ npm install pts-lang
\end{minted}

Add a start and/or build script to \codeword{package.json}:

\begin{minted}{json}
    {
      "scripts": {
        "start": "pts-lang -i src/index.pts --run",
        "build": "pts-lang -i src/index.pts -o build/index"
      }
    }
\end{minted}

The start script only runs the program, and does not emit any files, while the build script transpiles the \codeword{src/index.pts} file to JavaScript.
If you would rather have TypeScript output you can use the \codeword{-t} flag to specify this:

\begin{minted}{bash}
    pts-lang -i src/index.pts -o build/index -t ts
\end{minted}

\subsection{A Real World Example}\label{subsec:a-real-world-example}


\begin{code}{typescript}{Real world example of PTS being used in React. In this example we create a component for fetching JSON when the component has been mounted, and then we re-use this functionality in our Pokemon-component.}{lst:pts-react}
    template FetchJson {
        class FetchJson extends Component {
            componentDidMount() {
                fetch(this.props.url)
                .then(response => response.json())
                .then(data =>
                this.setState(state => ({...state, data})))
            }
        }
    }

    pack Pokemon {
        inst FetchJson { FetchJson -> Pokemon };
        addto Pokemon extends Component {
            render() {
                if(this.state.data === undefined)
                return 'Loading...';

                const name = this.state.data.name;
                const image = this.state.data.sprites.front_default;
                return (
                <div>
                <img src={image} />
                <h1>{name}</h1>
                </div>
                )
            }
        }

        class App extends Component {
            render() {
                <Pokemon
                url="https://pokeapi.co/api/v2/pokemon/ditto" />
            }
        }
    }
\end{code}

\section{Conclusion}\label{sec:result-conclusion}

\subsection{Approach}\label{subsec:result-approach}

Did I choose the right approach?
TypeScript compiler fork might have been easier.


\section{Future Work}\label{sec:future-work}

\subsection{Diamond Problem}\label{subsec:diamond-problem}

essay

\subsection{Improve the Compilers Error Messages}\label{subsec:compiler-with-focus-on-error-messages}

As I mentioned shortly in subsection~\vref{subsec:the-ast-nodes} tree-sitter does have support for giving position of a syntax node, and this could be utilized to produce better error messages.
