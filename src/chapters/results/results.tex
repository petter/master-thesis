\chapter{Results}\label{ch:results}

\section{How Can PTS Be Used?}\label{sec:how-can-this-be-used?}

There are mainly two ways of using the PTS compiler:

\begin{itemize}
    \item Installing it globally, or
    \item Creating a PTS project
\end{itemize}

In the following sections we will look at how you can use install and use it for both approaches.

The PTS compiler requires you to have Node and NPM installed on your computer.

\subsection{Installing and Using PTS Globally}\label{subsec:installing-and-using-pts-globally}

Installing PTS globally will enable you to use PTS anywhere, and might be favorable if you are planning to create several smaller projects to test it out, or if you are not too experienced with the node ecosystem.
If you want to install the compiler globally you can do the following:

\begin{minted}{bash}
    $ npm install -g pts-lang
\end{minted}

This will give you access to the PTS compiler CLI through the command \codeword{pts-lang}.
By not specifying any command line arguments you get a helpful text describing how to use the compiler:

\begin{minted}{text}
$ pts-lang
Options:
      --help                      Show help                        [boolean]
      --version                   Show version number              [boolean]
  -i, --input                     Name of the input file [string] [required]
  -o, --output                    Name of the output file           [string]
  -v, --verbose                   Show extra information during
                                  transpilation                    [boolean]
  -t, --targetLanguage, --target  Target language of the transpiler
                                       [choices: "js", "ts"] [default: "js"]
  -r, --run                            [boolean] [required] [default: false]

Missing required argument: input
\end{minted}

\subsection{Creating a PTS Project}\label{subsec:creating-a-pts-project}

If you are using PTS for a specific project it might be better to set it up as a project dependency in npm.
When installed in a npm project the CLI is available to use through npm scripts or through accessing it directly from the \codeword{node\_modules} folder in your project.
The compiler can also be access through the API by importing it as with any other npm package.

Installing it inside a npm project will not require you to install it globally, as it will stay contained in the project.
This also means that any contributors of the project will not have to worry about installing PTS, as it will be installed when the project is set up.

To initialize an NPM project you can do the following:

\begin{minted}{bash}
    $ mkdir <project name>
    $ cd <project name>
    $ npm init -y
\end{minted}

With a project set up you can install the PTS compiler as following:

\begin{minted}{bash}
    $ npm install pts-lang
\end{minted}

With the PTS compiler installed in the project you can then set up some scripts to start and/or build the project.
This can be done by adding scripts to the project's \codeword{package.json}.
Below you can see an example of a section of a \codeword{package.json} file with scripts for running and building a file:

\begin{minted}{json}
    {
      "scripts": {
        "start": "pts-lang -i src/index.pts --run",
        "build": "pts-lang -i src/index.pts -o build/index"
      }
    }
\end{minted}

The start script only runs the program, and does not emit any files, while the build script transpiles the \codeword{src/index.pts} file to JavaScript.
If you would rather have TypeScript output you can use the \codeword{-t} flag to specify this:

\begin{minted}{bash}
    pts-lang -i src/index.pts -o build/index -t ts
\end{minted}

\subsection{A Real World Example}\label{subsec:a-real-world-example}

Now that we understand how to get PTS set up, let us look at how it can be used in a real world example, and how this enables the programmer to modularize the code base even further giving great flexibility.

The most common use of TypeScript is to create web applications.
Let us look at how PTS can help make this task easier for the programmer.
We will try to create a simple web application for displaying a Pokémon.
To do this we will use one of the most popular web frameworks, React.

React is a web framework developed by Facebook.
It makes creating scalable web projects easier to handle, through enabling the programmer to modularize collections of elements into "components".
These components are often created to make reuse of common elements easier, such as creating a styled button with certain features, or we could create a component to represent the entire web application.

Displaying one specific Pokémon can be pretty simple, however we would like to create a React component that can display information and a picture of any Pokémon.
We do not want to have to write down information about all Pokémon, so we will fetch this information from an API, more specifically the PokéAPI (\url{https://pokeapi.co/}).
This API lets us fetch data from all Pokémon.

We will start of with the task of fetching data.
As this is something you commonly want to do in web applications it might be a good idea to separate this logic into a separate template:

\begin{minted}{typescript}
    template FetchJSON {
        class FetchJSON extends Component {
            componentDidMount() {
                fetch(this.props.url)
                    .then(response => response.json())
                    .then(data =>
                        this.setState(state => ({...state, data}))
                    ).catch(error =>
                        this.setState(state => ({...state, error}))
                    );
            }
        }
    }
\end{minted}

The component we see above will fetch whatever URL we pass to it in its props and update the state with the results of the fetch.
If we for some reason should fail to fetch the data we will instead update the state with the error message we got.

In addition to fetching data, it might be useful to have a logger, which will log all state changes to the console.
This is often useful when working with React components as we are able to see when they update, and what the state was at the time of the update.
Such a logger could then also be separated into its own template, like the following:

\begin{minted}{typescript}
    template StateLogger {
        class StateLogger extends Component {
            componentDidUpdate() {
                console.log("State updated!", this.state);
            }
        }
    }
\end{minted}

Finally we would like to combine these into our Pokémon component, and add some logic for displaying the information.
We will do this inside of a package, so that this will produce an output:

\begin{minted}{typescript}
    pack Pokemon {
        inst FetchJson { FetchJson -> Pokemon };
        inst StateLogger { StateLogger -> Pokemon };
        addto Pokemon {
            render() {
                if(this.state.error) {
                    return (
                        <div>
                            <h1>An error occurred</h1>
                            <p>{this.state.error.message}</p>
                        </div>
                    );
                }

                if(this.state.data === undefined) {
                    return 'Loading...';
                }

                const name = this.state.data.name;
                const pokemonTypes = this.state.data.types;
                const image = this.state.data.sprites.front_default;
                return (
                    <div>
                        <img src={image} />
                        <h1>{name}</h1>

                        <h2>Types</h2>
                        <ul>
                            {pokemonTypes.map(pokemonType => (
                                <li>{pokemonType.name}</li>
                            ))}
                        </ul>
                    </div>
                )
            }
        }

    }
\end{minted}

We could then use our Pokémon component in our application by supplying a URL for the Pokémon to display, as seen below:

\begin{minted}{typescript}
    class App extends Component {
        render() {
            <Pokemon
            url="https://pokeapi.co/api/v2/pokemon/ditto" />
        }
    }
\end{minted}

\section{Conclusion}\label{sec:result-conclusion}

\subsection{Approach}\label{subsec:result-approach}

Did I choose the right approach?
TypeScript compiler fork might have been easier.


\section{Future Work}\label{sec:future-work}

\subsection{Diamond Problem}\label{subsec:diamond-problem}

essay

\subsection{Improve the Compilers Error Messages}\label{subsec:compiler-with-focus-on-error-messages}

As I mentioned shortly in subsection~\vref{subsec:the-ast-nodes} tree-sitter does have support for giving position of a syntax node, and this could be utilized to produce better error messages.
