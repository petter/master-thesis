%! Author = petter
%! Date = 04.01.2021

\chapter{Difference between PTS and PTj}\label{ch:difference-between-pts-and-ptj}


\section{Nominal vs. Structural Typing}\label{sec:nominal-vs-structural-typing}

%Much taken from TAPL.

One of the most notable differences between PTS and PTj are the underlying languages type systems.
PTS, as an extension of TypeScript, has structural typing, while PTj on the other hand, an extension of Java, has nominal typing.

Nominal and structural are two major categories of type systems.
Nominal is defined as "being something in name only, and not in reality" in the Oxford dictionary.
Nominal types are as the name suggest, types in name only, and not in the structure of the object.
They are the norm in mainstream programming languages, such as Java, C, and C++.
A type could be \codeword{A} or \codeword{Tree}, and checking whether an object conforms to a type restriction, is to check that the type restriction is referring to the same named type, or a subtype.
Structural types on the other hand is not tied to the name of the type, but to the structure of the object.
These are not as common in mainstream programming languages, but are very prominent in research literature.
However, in more recent (mainstream) programming languages, such as Go, TypeScript and Julia (at least for implicit typing), structural typing is becoming more and more common.
A type in a structurally typed programming language is often defined as a record, and could for example be \codeword{\{ name:~string \}}.

\subsection{Advantages of Nominal Types}\label{subsec:advantages-of-nominal-types}

\subsubsection{Subtypes}\label{subsubsec:subtypes}

In nominal type systems it is trivial to check if a type is a subtype of another, as this has to be explicitly stated, while in structural type systems this has to be structurally checked, by checking that all members of the super type, are also present in the subtype.
Because of this each subtype relation only has to be checked once for each type, which makes it easier to make a more performant type checker for nominal type systems.
However, it is also possible to achieve similar performance in structurally typed languages through some clever representation techniques~\cite{tapl}. % TODO: Maybe find an article describing this
We can see an example of subtype relations in both nominal and structural type systems, in a Java-like language, in listing~\vref{lst:subtype}.
It is important to note that even though \codeword{C} is a \emph{subtype} of \codeword{A} in a structural language, it is not a \emph{subclass} of \codeword{A}.

\begin{code}{Java}{Example of subtype relations in nominal and structural typing, in a Java-like language. In the example of the nominal subtype we have to explicitly state the subtype relation, while in the structural subtype example the subtype relation is inferred from the common attributes.}{lst:subtype}
    // Given class A
    class A {
        void f() { ... }
     }

    // A subtype, B, in nominal typing
    class B extends A { ... }

    // A subtype, C, in structural typing
    class C {
        void f() { ... }
        int g() { ... }
    }
\end{code}

% TODO: Vurder om recursive types er verdt Ã¥ ta med
% \subsubsection{Recursive types}\label{subsubsec:recursive-types}
%
% Recursive types are types that mention itself in its definition, and are widely used in datastructures, such as lists and trees.
% An advantage in nominal typing is how natural and intuitive recursive types are in the type system.
% Referring to itself in a type definition is as easy as referring to any other type.
% It is however just as easy to do this in structural type systems as well, however for calculi such as type safety proofs, recursive types come for free in nominal type systems, while it is a bit more cumbersome in structurally typed systems, especially with mutually recursive types~\cite{tapl}.
% Listings~\vref{lst:ts-recursive-type} and~\vref{lst:java-recursive-type} shows the use of recursive types in TypeScript (structurally typed) and Java (nominally typed), respectively.
%
% \begin{code}{TypeScript}{Usage of a recursive type, \codeword{Tree}, in TypeScript}{lst:ts-recursive-type}
%     interface Tree<T> {
%         getData(): T;
%         getChildren(): Tree<T>[];
%     }
% \end{code}
%
% \begin{code}{Java}{Usage of a recursive type, \codeword{Tree}, in Java}{lst:java-recursive-type}
%     interface Tree<T> {
%         T getData();
%         List<Tree<T>> getChildren();
%     }
% \end{code}

\subsubsection{Runtime Type Checking}\label{subsubsec:runtime-type-checking}

Often runtime-objects in nominally typed languages are tagged with the types (a pointer to the "type") of the object.
This makes it cheap and easy to do runtime type checks, like in upcasting or doing a \codeword{instanceof} check in Java.
It is also easier to check sub-type relations in nominal type systems, even though you might still have to do a structural comparison, you only have to perform this once per type.
% TODO: Skriv mere

\subsection{Advantages of Structural Types}\label{subsec:advantages-of-structural-types}

\subsubsection{Tidier and More Elegant}\label{subsubsec:tidier-and-more-elegant}

Structural types carry with it all the information needed to understand its meaning.
This is often seen as an advantage over nominal typing as the programmer only has to look at the type to understand it, while in nominal typing you would often have to look at the implementation or documentation to understand the type, as the type itself is part of a global collection of names.

\subsubsection{Advanced Features}\label{subsubsec:advanced-type-features}

Type abstractions (parametric polymorphism, ADTs, user-defined type operators, functors, etc), these do not fit nice into nominal type systems.

\subsubsection{More General Functions/Classes}\label{subsubsec:more-general-functions}

Malayeri and Aldrich performed a study (see~\cite{malayeri}) on the usefulness of structural subtyping.
The study was mainly focused around two characteristics of nominally-typed programs that would indicate that they would benefit from a structurally typed program.
The first characteristic was that a program is systematically making use of a subset of methods of a type, in which there is no nominal type corresponding to the subset.
The second characteristic was that two different classes might have methods which are equal in name and perform the same operation, but are not contained in a common nominal supertype.
29 open-source Java projects were examined for these characteristics.

For the first characteristic the authors ran structural type inference over the projects and found that on average the inferred structural type consisted of 3.5 methods, while the nominal types consisted of 37.8 methods.
While for the second characteristic the authors looked for types with more than one common methods and found that every 2.9 classes would have a common method without a common nominal supertype.
We can see that from both of these characteristics that the projects could have benefited from a structural type system, as this would make the programs more generalized, and could therefore support easier re-use of code.

\subsection{Disadvantage of Structural Type Systems}\label{subsec:disadvantage-of-structural-type-systems}

It is worth noting that the advantage of types conforming to each other without explicitly stating it in structural type systems can also be a disadvantage.
Structurally written programs can be prone to \textit{spurious subsumption}, that is consuming a structurally equal type where it should not be consumed.
An example of this can be seen in listing~\vref{lst:spurious-subsumption}.

\begin{code}{typescript}{Example of spurious subsumption in TypeScript. Here the function \codeword{double} will consume an object that has a \codeword{calculate} attribute. The intended use is to consume something that does a calculation on the object and returns a number which will be doubled, while the unintended use example in this case does some unexpected side-effect and returns a number as a status code. The unintended object can be consumed by the \codeword{double} function as it is conforms to the signature of the function, while in a nominally typed system this can be avoided to a much larger extent.}{lst:spurious-subsumption}
    function double(o: {calculate: () => number}) {
        return o.calculate() * 2
    }

    const vector = {
        x: 2,
        y: 3,
        calculate: () => 4
    }

    const unintended = {
        calculate: () => {
            doSomeSideEffect();
            return 1;
        }
    }
\end{code}

\subsection{What Difference Does This Make For PT?}\label{subsec:what-difference-does-this-make-for-pt?}

We are not going to go further into comparing nominal and structural type systems and "crown a winner", as there are a lot useful scenarios for both nominal and structural type systems.
We will instead look more closely into how a structural type system fits into PT, and what differences this makes to the features, and constraints, of this language mechanism.


%Often runtime-objects are tagged with the types, which are useful for multiple things like doing runtime instanceof checks. (This can also be used in structural typing)
%It is "easier" to check sub-type relations in nominal type systems, even though you will still have to do a structural comparison, you only have to do this calculation once per type.
%    Even though it is easier to achieve better performance for nominal vs structural types, it is still possible to achieve close to if not equal performance in structural type systems, through some representation techniques(Consider finding a article on this).
%A questionable advantage for nominal typing is that they prevent "spurious subsumption", that is using a structurally equal type in a place where it should not be used.
%    I would argue that there are more cases where this is a compromise than a benefit, and there are better ways to prevent this from happening, such as single-constructor datatypes or ADTs.
%
%nominal cons:
%
%structural pros:
%
%
%structural cons:
%




\begin{code}{Java}{Example of a nominally typed program in a Java-like language}{lst:nominal-typing-example}
    // Given the following class definitions for A, B and C:
    class A {
        void f() {
            ...
        }
    }

    class B extends A {
        ...
    }

    class C {
        void f() {
            ...
        }
    }

    // And a consumer with the following type:
    void g(A a) { ... }

    // Would result in the following
    g(new A()); // Ok
    g(new B()); // Ok
    g(new C()); // Error, C not of type A
\end{code}


\begin{code}{Java}{Example of a structurally typed program in a Java-like language}{lst:structural-typing-example}
    // Given the same class definitions and
    // the same consumer as in the example above.
    // Would result in the following
    g(new A()); // Ok
    g(new B()); // Ok
    g(new C()); // Ok, because C is structurally equal to A
\end{code}

\subsection{Which Better Fits PT?}\label{subsec:which-better-fits-pt?}

With the addition of required types in PT the language mechanism now has to utilize structural typing, independent of the underlying language's type system.
Required types in PT already uses structural typing, even if the underlying language might be using a nominal type system.
This is because PT doesn't allow using externally declared classes, interfaces, etc., so in order to be able to have constraints on generic types structural typing was needed.
I would therefore argue that a structurally typed language is a better fit for PT in order to make it feel more like a first-class citizen.
Having two different type systems for different contexts might prove to be confusing for the programmer.

It is important to note that even though structural typing might seem like a better fit for the current proposal of PT, there will certainly be proposals in the future where nominal type systems will prove to be the victor.
The reader should also note that an implementation of PT in a language should not aim to change the underlying type system of the host language, as this will certainly only lead to more confusion than what we have explored in this chapter.

\section{Attribute Renaming}\label{sec:attribute-renaming}

Don't need full signature in PTS, because no overloading, etc.
Might be easier to understand PTS version?