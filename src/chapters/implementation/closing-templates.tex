The task of closing open packages and templates is what most of the implementation is focused around.
It is the task of performing the declared instantiations and altering the declared classes through \codeword{addto}-statements.
This step is cruicial as it will make each package/template a valid TypeScript program and make the program ready for code generation.

For instantiations without renaming the task is fairly simple.
We merely have to find the referenced template, and replace the instantiation statement with the body of said template.
Renaming on the other hand requires a bit more work.

In order to perform renaming on an instantiation we will have to perform the following tasks.
\begin{enumerate}
    \item Create a scope for the template body, and give all nodes of the body access to this scope
    \item Find all identifiers, member expressions, class declarations, etc., and replace them with \textit{reference nodes}\footnote{Reference nodes are AST nodes that contain a pointer to the class or attribute they are supposed to represent. This makes the task of renaming easier as we only have to worry about changing the name in one place. We will go into more detail about this in section~\vref{subsec:transforming-nodes-to-references}.}
    \item Perform the rename.
    \item Transform the scoped AST with reference nodes back to the original AST\@.
    \item Merge class declarations and apply \codeword{addto} statements.
\end{enumerate}

If the template body is also open we would have to close it as well.
We want to close the nested templates before closing the upper templates, as renaming at the top level should affect all members from the nested instantiations.

Finally, once all templates have been closed we will have to perform class merging and apply any additions to classes.

In order to get a better understanding of this we will go through each step of closing a template in more detail.

%\begin{code}{}{Pseudocode for closing a template. The same code could also be used to close a package, as they are essentially equal in this regard.}{lst:pseudo-close-pacakge}
%    templates <- map from template name to body
%    FUNCTION close_template(template_body)
%        new_program <-
%            MAP syntax_node IN template_body
%                IF syntax_node IS instantiation statement THEN
%                    instantiated_template_body <- LOOKUP referenced template from instantiation statement IN templates
%                    closed_template_body <- close_template(instantiated_template_body)
%                    scoped_body <- add_scope(closed_template_body)
%
%                    renamings <- get renamings from instantiation statement
%                    FOR renaming IN
%                ELSE
%                    syntax_node
%                END IF
%            END MAP
%        RETURN new_program
%    END FUNCTION
%
%    FUNCTION
%\end{code}

\subsection{Scoping}\label{subsec:inst-scoping}

This step of closing templates works on the body of a copy of the instantiated template.
In order to be able to rename classes and class attributes we first need to create correct scopes in which the renaming can be applied to.
We start of with a list of normal AST nodes and will transform these nodes into nodes that has a reference to the scope they are part of.

Scopes in the compiler mainly consists of three different classes.
The \codeword{Scope}, \codeword{Variable}, and \codeword{Class} classes.

The \codeword{Scope} class is essentially a symbol table that optionally extends a parent scope.
A scope without a reference to a parent scope is the root scope.
The symbol table is implemented as a map from the original attribute or class name, to a reference to either \codeword{Variable} or \codeword{Class} instance.
Looking up symbols in the symbol table will always start in the called scope, and work its way upwards until we reach the root scope.
This allows us to correctly handle shadowed variables.

The \codeword{Variable} class is a representation for class attributes.
The class contains the name of the attribute.


For creating scopes I chose the following node types for "making new scopes".

\begin{multicols}{2}
\begin{itemize}
    \item \codeword{class\_body}
    \item \codeword{statement\_block}
    \item \codeword{enum\_body}
    \item \codeword{if\_statement}
    \item \codeword{else\_statement}
    \item \codeword{for\_statement}
    \item \codeword{for\_in\_statement}
    \item \codeword{while\_statement}
    \item \codeword{do\_statement}
    \item \codeword{try\_statement}
    \item \codeword{with\_statement}
\end{itemize}
\end{multicols}

\subsection{Transforming Nodes to References}\label{subsec:transforming-nodes-to-references}

Transforming nodes into references mainly consists of two steps.

\begin{itemize}
    \item Transform declarations
    \item Transform references
\end{itemize}

\subsubsection{Transform Declarations}

The task of transforming declarations requires several passes through the AST\@.
This is because in order to register som declarations we need to have others registered.
To understand this we can look at the difference between the first and second pass.

During the first pass through the AST we register and transform all class declarations.
Now for the second pass we register class heritage.
The second pass needs to update the \codeword{Class} instances from the first pass with what class they are extending.
If we try to do this in a single pass we would have to register classes

\subsubsection{Transform References}

\subsection{Performing the Rename}\label{subsec:performing-the-rename}

With all declarations and references transformed into reference nodes we can now perform the rename.
For each class rename we can simply lookup the old class name in the root scope and change the reference to the new class name.
For class attribute renames we do the same just for the enclosing classes scope.

\subsection{Going back to the original AST}\label{subsec:going-back-to-the-original-ast}

reference -> original with new names
remove scope

\subsection{Merging Class Declarations}\label{subsec:merging-class-declarations}

Check if can be merged, non overlapping members.
Override and merge addto