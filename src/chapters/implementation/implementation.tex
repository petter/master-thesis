%! Author = petter
%! Date = 04.01.2021

\chapter{Implementation}\label{ch:implementation}

In this chapter we are going to look at the implementation for our compiler for PTS, as described in chapter~\vref{ch:the-language---pts}.
Before looking at the implementation we will first be discussing the methodology used during development.

\section{Methodology}\label{sec:methodology}

When tackling a project of this magnitude it is important to have a proper methodology for development.
During the development phase of this project I have had a strong focus on using agile techniques, where I have filled the role as both product owner and developer.
This agile software development has aided me in discovering new requirements as the project moves forward, and re-adjusting to these new requirements.
I have actively used a Kanban board throughout development to help keep track of tasks and goals.

The compiler was made in an iterative manner.
For each iteration I would start off by implementing a new feature, and then put on the product owner hat and test out the compiler.
While working as product owner I try to understand how I would like to use the language and what requirements I have for the language.
This often leads to re-adjusting the requirements.

I started off by creating a rough MVP (Minimum Viable Product), only implementing the most basic functionality, which comprised declaration of packages/templates and simple instantiation.
This MVP made me understand the project and requirements better, and also gave the project some new requirements.
After the initial iteration I decided to adopt a test-driven development approach.
I made tests for the features I had already implemented and then continued to make tests for the next functionality goal.
This was done in order to gain more confidence in the compiler, as well as helping me spot any erroneous code earlier rather than later, which makes fixing it less costly.
All of this resulted in a better development cycle, making refactoring and implementation of new features a breeze.
When adding new features or refactoring some tests will undoubtedly fail, and before moving on I made sure that all the tests were passing again.


\section{Compiler Architecture}\label{sec:architecture}

Our compiler consists of the following parts:

\begin{itemize}
    \item Lexing and parsing
    \item Parse tree transformation
    \item Type checking packages/templates
    \item Code generation
\end{itemize}

An overview of our architecture can be seen in figure~\vref{fig:compiler-overview}.
The first part of the compiler, namely the lexing and parsing will take a source file and transform it into a parse tree.
Our compiler will then take this parse tree and transform it into a simpler abstract syntax tree (AST).
This AST will then be used to perform the PT transformations.
We will then use this AST to close any open packages and templates, and finally use the transformed tree for code generation.
After all packages and templates have been closed we can type-check each individual package/template to validate the type-safety of our program.
Given a valid type-safe program we can then move on to code generation.
The target language for our code generation will mainly be TypeScript, however we will also offer to transpile the TypeScript into JavaScript.

\begin{figure}
   \centering
   \includegraphics[scale=.75]{images/Compiler overview.png}
   \caption{Overview of the compiler}
   \label{fig:compiler-overview}
\end{figure}

\section{Lexer and Parser}\label{sec:lexer-and-parser}
\input{chapters/implementation/lexer-and-parser}

\section{Transforming Parse Tree to AST}\label{sec:transforming-parse-tree-to-ast}
\input{chapters/implementation/parse-tree-to-ast.tex}

\section{Closing Templates}\label{sec:closing-templates}
\input{chapters/implementation/closing-templates}

\section{Type-checking of Templates}\label{sec:type-checking-of-templates}

After the previous step we have a program where all packages and templates are closed, meaning that the bodies of these should contain plain TypeScript.
Because of this we can relatively easily type-check each package/template individually by using the TypeScript compiler and its compiler API\@.
In order for us to type-check our pacakges/templates we will have to transform the bodies of the packages/templates into a textual format.
This will be done by applying our code generation implementation, which we will discuss in section~\vref{sec:code-generation}, to the body of the package/template we are currently working on.
Running code generation on the package/template body will give us a TypeScript program.
This program can then be passed on to the TypeScript compiler for type-checking.
We will make the TypeScript compiler transpile the program to JavaScript without emitting any output.
This will effectively type-check the program.

If the TypeScript compiler throws any errors we can log this for the user of our compiler to fix, and inform in which package/template this error occurred.
If no errors were thrown we have a type-safe package/template, and we can then proceed to the next step in our compilation.

\section{Code Generation}\label{sec:code-generation}

After performing these steps we can finally produce the output.
Producing TypeScript output is a pretty simple task.
By traversing the AST we can concatenate the text from each leaf node with whitespace between each leaf node's resulting textual representation.
This will produce quite ugly, unformatted code, but as long as the contents of the closed packages and templates are valid typescript programs this will also produce a valid typescript program.
In order to make it more readable we perform an extra step before writing the output to the specified file, a formatting step.
There are a lot of TypeScript formatters out there, but we will be using \textit{Prettier}\footnote{A code formatter for the web ecosystem. See~\url{https://prettier.io/}.} for our implementation as it is relatively simple to use.
Running our produced source code through the Prettier formatter produces a nicely formatted, readable output.

The TypeScript output is probably the best target for understanding what the PT mechanism does, however it might not be the best output for production use.
Since the only officially supported language for the web is JavaScript we will also be implementing this as a target for code generation.
This is fortunately also a relatively simple task, as we already depend on the TypeScript compiler, and since we are able to produce TypeScript source code, we can use this to produce JavaScript output.
% TODO: Undersøk  hvilken ES versjon vi outputter til og om dette kan være lavere.

\section{Notes on Performance}\label{sec:notes-on-performance}

Very slow compiler/PP because of the chosen implementation, with tree traverser for every step.


\section{Testing}\label{sec:testing}

Testing has been an essential part throughout the development of the compiler.
After the initial prototype of the compiler was running I continued onward with test driven development.
This allows me to write up tests for all the features of the language, and run them concurrently as I make the changes to the implementation.

The cycle

\subsection{Lexer and Parser}\label{subsec:testing-lexer-and-parser}

Tree-sitter tests are simple \codeword{.txt} files split up into three sections, the name of the test, the code that should be parsed, and the expected parse tree in \textit{S-expressions}\footnote{S-expressions are textual representations for tree-structured data. See~\cite{sexprs} for additional information and examples}.

\begin{code}{typescript}{Example of tree-sitter grammar test}{lst:tree-sitter-grammar-test}
    ===========================
    Closed template declaration
    ===========================

    template T {
        class A {
            i = 0;
        }
    }

    ---
    (program
        (template_declaration
            name: (identifier)
            body: (package_template_body
                    (class_declaration
                        name: (type_identifier)
                        body: (class_body
                            (public_field_definition
                                name: (property_identifier)
                                value: (number)))))))

\end{code}

\subsection{Transpiler}\label{subsec:testing-transpiler}

Started with jest, and used some time to get it to work with typescript files, however had to switch because jest doesn't handle native libraries (tree-sitter) too well.
It \codeword{require}s the same native library several times, making the wrapping around the native program to break.


\section{Completing the Implementation}\label{sec:completing-the-implementation}

\subsection{\codeword{addto}-statements}\label{subsec:addto-statements}

\codeword{addto}-statements is one of the core features of PT I was not able to finish in the allotted time.
As of now \codeword{addto}-statements just work as any other class declaration, and will simply be merged together with the other class declarations.
The only difference is that an \codeword{addto}-statement requires there to be at least one class declaration.
This is to avoid the programmer running into bugs where the programmer is trying to add attributes to a non-existent class.

There are mainly two ways for us to implement \codeword{addto}-statements as of now, one hacky but cheap implementation, and one more robust but expensive implementation.
The cheap and hacky way is to simply always merge the bodies of the \codeword{addto}-statement at the bottom of the formed merged class.
This will work because of the JavaScript's prototype-based object-orientation.
Since the class syntax is only syntactic sugar for creating a prototype object and a constructor function, this means that any attributes that are lower down in the prototype object will override any previously declared attributes.
So if we in a \codeword{addto}-statement wish to override an attribute we will utilize overriding of properties in objects to achieve this.
The hacky part of the implementation is that TypeScript gives errors for duplicate declarations inside the class syntax, as this is often a sign of performing a mistake.
In order for us to still be able to pass the type-check we will have to bypass the TypeScript compilers errors for certain lines by prefixing all attribute declarations in the bodies of \codeword{addto}-statements with a \codeword{// @ts-ignore}.
This will unfortunately have the drawback of not having any type-checks for these function-declarations.

The better more robust way to fix this will force us to make a quite severe refactor of the majority of the codebase.
With this approach we will have to create more complicated datastructures for classes and class attributes.
With our current implementation we are simply combining two AST trees when merging classes, not really worrying about what is contained within these trees.
In order for us to be able to override attributes with the \codeword{addto}-statements we will have to merge the bodies of classes in a smarter way.
I suggest that before class merging that the AST nodes representing classes or \codeword{addto}s are transformed, as well as their contained attribute declarations.
Class nodes can be transformed to containing a body of attribute nodes, instead of general AST nodes, and the attribute declarations will be transformed to a pair of the name of the attribute, and the old AST representation of the attribute.
This will enable us to perform smarter merges, as we have easy access to the contained attributes.
For class declarations this will enable us to give better error messages when merging classes resulting in duplicate attribute declarations, and for \codeword{addto} this enables us to replace the attributes that will be overridden.
This was attempted in the implementation, but had to be discarded because of the time constraint.
The attempted implementation can be found under the experimental branch in the GitHub repository, \url{https://github.com/petter/pts/tree/experimental}.
This implementation also tries to achieve better representations for templates and packages to contain these new class representations.
