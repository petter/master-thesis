%! Author = petter
%! Date = 04.01.2021

\chapter{Implementation}\label{ch:implementation}

In this chapter we are going to look at the implementation for our compiler for PTS, as described in chapter~\vref{ch:the-language---pts}.

\section{Compiler Architecture}\label{sec:architecture}

Our compiler consists of the following parts:

\begin{itemize}
    \item Lexing and parsing
    \item Parse tree transformation
    \item Type checking packages/templates
    \item Code generation
\end{itemize}

An overview of our architecture can be seen in figure~\vref{fig:compiler-overview}.
The first part of the compiler, namely the lexing and parsing will take a source file and transform it into a parse tree.
Our compiler will then take this parse tree and transform it into a simpler AST\@.
This simple AST will then be used to perform the PT transformations.
We will then use this AST to close any open packages and templates, and finally use the transformed tree for code generation.
After all packages and templates have been closed we can type-check each individual package/template to validate the type-safety of our program.
Given a valid type-safe program we can then move on to code generation.
The target language for our code generation will mainly be TypeScript, however we will also offer to transpile the TypeScript into JavaScript.

\begin{figure}
   \centering
   \includegraphics[scale=.75]{images/Compiler overview.png}
   \caption{Overview of the compiler}
   \label{fig:compiler-overview}
\end{figure}

\section{Lexer and Parser}\label{sec:lexer-and-parser}
\input{chapters/implementation/lexer-and-parser}

\section{Transforming Parse Tree to AST}\label{sec:transforming-parse-tree-to-ast}
\input{chapters/implementation/parse-tree-to-ast.tex}

\section{Closing Templates}\label{sec:closing-templates}
\input{chapters/implementation/closing-templates}

\section{Verification of Templates}\label{sec:verification-of-templates}

ts api

\section{Code Generation}\label{sec:code-generation}

After performing these steps we can finally produce the output.
Producing TypeScript output is a pretty simple task.
By traversing the AST we can concatenate the text from each leaf node and insert some whitespace between them.
This will produce quite ugly, unformatted code, but as long as the closed packages and templates are valid typescript programs this will also produce a valid typescript program.
In order to make it a bit more clean we perform an extra step before writing the output to the specified file, a formatting step.
There are a lot of TypeScript formatters out there, but we will be using \textit{Prettier} for our implementation.
Running our produced source code through the prettier formatter produces a nicely formatted, readable output.

Since browsers only support JavaScript we will also be implementing this as a target for code generation.
This is fortunately also a simple task, as we already dependent on the TypeScript compiler, and we are able to produce TypeScript source code, we can use this to produce JavaScript output.
% TODO: Undersøk  hvilken ES versjon vi outputter til og om dette kan være lavere.

\section{Notes on Performance}\label{sec:notes-on-performance}

Very slow compiler/PP because of the chosen implementation, with tree traverser for every step.


\section{Testing}\label{sec:testing}

\subsection{Lexer and Parser}\label{subsec:testing-lexer-and-parser}

Tree-sitter tests are simple \codeword{.txt} files split up into three sections, the name of the test, the code that should be parsed, and the expected parse tree in \textit{S-expressions}\footnote{S-expressions are textual representations for tree-structured data. See~\cite{sexprs} for additional information and examples}.

\begin{code}{typescript}{Example of tree-sitter grammar test}{lst:tree-sitter-grammar-test}
    ===========================
    Closed template declaration
    ===========================

    template T {
        class A {
            i = 0;
        }
    }

    ---
    (program
        (template_declaration
            name: (identifier)
            body: (package_template_body
                    (class_declaration
                        name: (type_identifier)
                        body: (class_body
                            (public_field_definition
                                name: (property_identifier)
                                value: (number)))))))

\end{code}

\subsection{Transpiler}\label{subsec:testing-transpiler}

Started with jest, and used some time to get it to work with typescript files, however had to switch because jest doesn't handle native libraries (tree-sitter) too well.
It \codeword{require}s the same native library several times, making the wrapping around the native program to break.