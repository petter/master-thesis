%! Author = petter
%! Date = 04.01.2021

\chapter{Implementation}\label{ch:implementation}

In this chapter we are going to look at the implementation of PTS.

\section{Compiler Architecture}\label{sec:architecture}

\begin{figure}
   \centering
   \includegraphics[scale=.75]{images/Compiler overview.png}
   \caption{Overview of the compiler}
   \label{fig:compiler-overview}
\end{figure}

\section{Lexer and Parser}\label{sec:lexer-and-parser}
\input{chapters/implementation/lexer-and-parser}

\section{Transforming Parse Tree to AST}\label{sec:transforming-parse-tree-to-ast}
\input{chapters/implementation/parse-tree-to-ast.tex}

\section{Closing Templates}\label{sec:closing-templates}
\input{chapters/implementation/closing-templates}

\section{Verification of Templates}\label{sec:verification-of-templates}

ts api

\section{Code Generation}\label{sec:code-generation}

After performing these steps we can finally produce the output.
Producing TypeScript output is a pretty simple task.
By traversing the AST we can concatenate the text from each leaf node and insert some whitespace between them.
This will produce quite ugly, unformatted code, but as long as the closed packages and templates are valid typescript programs this will also produce a valid typescript program.
In order to make it a bit more clean we perform an extra step before writing the output to the specified file, a formatting step.
There are a lot of TypeScript formatters out there, but we will be using \textit{Prettier} for our implementation.
Running our produced source code through the prettier formatter produces a nicely formatted, readable output.

Since browsers only support JavaScript we will also be implementing this as a target for code generation.
This is fortunately also a simple task, as we already dependent on the TypeScript compiler, and we are able to produce TypeScript source code, we can use this to produce JavaScript output.
% TODO: Undersøk  hvilken ES versjon vi outputter til og om dette kan være lavere.

\section{Notes on Performance}\label{sec:notes-on-performance}

Very slow compiler/PP because of the chosen implementation, with tree traverser for every step.


\section{Testing}\label{sec:testing}

\subsection{Lexer and Parser}\label{subsec:testing-lexer-and-parser}

Tree-sitter tests are simple \codeword{.txt} files split up into three sections, the name of the test, the code that should be parsed, and the expected parse tree in \textit{S-expressions}\footnote{S-expressions are textual representations for tree-structured data. See~\cite{sexprs} for additional information and examples}.

\begin{code}{typescript}{Example of tree-sitter grammar test}{lst:tree-sitter-grammar-test}
    ===========================
    Closed template declaration
    ===========================

    template T {
        class A {
            i = 0;
        }
    }

    ---
    (program
        (template_declaration
            name: (identifier)
            body: (package_template_body
                    (class_declaration
                        name: (type_identifier)
                        body: (class_body
                            (public_field_definition
                                name: (property_identifier)
                                value: (number)))))))

\end{code}

\subsection{Transpiler}\label{subsec:testing-transpiler}

Started with jest, and used some time to get it to work with typescript files, however had to switch because jest doesn't handle native libraries (tree-sitter) too well.
It \codeword{require}s the same native library several times, making the wrapping around the native program to break.