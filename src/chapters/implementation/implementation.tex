%! Author = petter
%! Date = 04.01.2021

\chapter{Implementation}\label{ch:implementation}

In this chapter we are going to look at the implementation for our compiler for PTS, as described in chapter~\vref{ch:the-language---pts}.
Before looking at the implementation we will first be discussing the methodology used during development.

\section{Methodology}\label{sec:methodology}

When tackling a project of this magnitude it is important to have a proper methodology for development.
During the development phase of this project I have had a strong focus on using agile techniques, where I have filled the role as both product owner and developer.
This agile software development has aided me in discovering new requirements as the project moves forward, and re-adjusting to these new requirements.
I have actively used a Kanban board throughout development to help keep track of tasks and goals.

The compiler was made in an iterative manner.
For each iteration I would start off by implementing a new feature, and then put on the product owner hat and test out the compiler.
While working as product owner I try to understand how I would like to use the language and what requirements I have for the language.
This often leads to re-adjusting the requirements.

I started off by creating a rough MVP (Minimum Viable Product), only implementing the most basic functionality, which comprised declaration of packages/templates and simple instantiation.
This MVP made me understand the project and requirements better, and also gave the project some new requirements.
After the initial iteration I decided to adopt a test-driven development approach.
I made tests for the features I had already implemented and then continued to make tests for the next functionality goal.
This was done in order to gain more confidence in the compiler, as well as helping me spot any erroneous code earlier rather than later, which makes fixing it less costly.
All of this resulted in a better development cycle, making refactoring and implementation of new features a breeze.
When adding new features or refactoring some tests will undoubtedly fail, and before moving on I made sure that all the tests were passing again.


\section{Compiler Architecture}\label{sec:architecture}

Our compiler consists of the following parts:

\begin{itemize}
    \item Lexing and parsing
    \item Parse tree transformation
    \item Type checking packages/templates
    \item Code generation
\end{itemize}

An overview of our architecture can be seen in figure~\vref{fig:compiler-overview}.
The first part of the compiler, namely the lexing and parsing will take a source file and transform it into a parse tree.
Our compiler will then take this parse tree and transform it into a simpler abstract syntax tree (AST).
This AST will then be used to perform the PT transformations.
We will then use this AST to close any open packages and templates, and finally use the transformed tree for code generation.
After all packages and templates have been closed we can type-check each individual package/template to validate the type-safety of our program.
Given a valid type-safe program we can then move on to code generation.
The target language for our code generation will mainly be TypeScript, however we will also offer to transpile the TypeScript into JavaScript.

\begin{figure}
   \centering
   \includegraphics[scale=.75]{images/Compiler overview.png}
   \caption{Overview of the compiler}
   \label{fig:compiler-overview}
\end{figure}

\section{Lexer and Parser}\label{sec:lexer-and-parser}
\input{chapters/implementation/lexer-and-parser}

\section{Transforming Parse Tree to AST}\label{sec:transforming-parse-tree-to-ast}
\input{chapters/implementation/parse-tree-to-ast.tex}

\section{Closing Templates}\label{sec:closing-templates}
\input{chapters/implementation/closing-templates}

\section{Verification of Templates}\label{sec:verification-of-templates}

ts api

\section{Code Generation}\label{sec:code-generation}

After performing these steps we can finally produce the output.
Producing TypeScript output is a pretty simple task.
By traversing the AST we can concatenate the text from each leaf node with some whitespace between each leaf node.
This will produce quite ugly, unformatted code, but as long as the closed packages and templates are valid typescript programs this will also produce a valid typescript program.
In order to make it more readable we perform an extra step before writing the output to the specified file, a formatting step.
There are a lot of TypeScript formatters out there, but we will be using \textit{Prettier}\footnote{A code formatter for the web ecosystem. See~\url{https://prettier.io/}.} for our implementation as it is relatively simple to use.
Running our produced source code through the Prettier formatter produces a nicely formatted, readable output.

The TypeScript output is probably the best target for understanding what the PT mechanism does, however it might not be the best output for production use.
Since the only officially support language for the web is JavaScript we will also be implementing this as a target for code generation.
This is fortunately also a relatively simple task, as we already depend on the TypeScript compiler, and since we are able to produce TypeScript source code, we can use this to produce JavaScript output.
% TODO: Undersøk  hvilken ES versjon vi outputter til og om dette kan være lavere.

\section{Notes on Performance}\label{sec:notes-on-performance}

Very slow compiler/PP because of the chosen implementation, with tree traverser for every step.


\section{Testing}\label{sec:testing}

Testing has been an essential part throughout the development of the compiler.
After the initial prototype of the compiler was running I continued onward with test driven development.
This allows me to write up tests for all the features of the language, and run them concurrently as I make the changes to the implementation.

The cycle

\subsection{Lexer and Parser}\label{subsec:testing-lexer-and-parser}

Tree-sitter tests are simple \codeword{.txt} files split up into three sections, the name of the test, the code that should be parsed, and the expected parse tree in \textit{S-expressions}\footnote{S-expressions are textual representations for tree-structured data. See~\cite{sexprs} for additional information and examples}.

\begin{code}{typescript}{Example of tree-sitter grammar test}{lst:tree-sitter-grammar-test}
    ===========================
    Closed template declaration
    ===========================

    template T {
        class A {
            i = 0;
        }
    }

    ---
    (program
        (template_declaration
            name: (identifier)
            body: (package_template_body
                    (class_declaration
                        name: (type_identifier)
                        body: (class_body
                            (public_field_definition
                                name: (property_identifier)
                                value: (number)))))))

\end{code}

\subsection{Transpiler}\label{subsec:testing-transpiler}

Started with jest, and used some time to get it to work with typescript files, however had to switch because jest doesn't handle native libraries (tree-sitter) too well.
It \codeword{require}s the same native library several times, making the wrapping around the native program to break.