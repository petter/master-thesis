%! Author = petter
%! Date = 04.01.2021

\chapter{Implementation}\label{ch:implementation}

In this chapter we are going to look at the implementation of PT in TypeScript.

\section{Architecture / Parts of the compiler / PP}\label{sec:architecture}



\subsection{Lexer and Parser}\label{subsec:lexer-and-parser}

tree-sitter grammar extending tree-sitter-typescript

\subsection{Instantiation and Renaming}\label{subsec:instantiation-and-renaming}


\subsection{Verification of Templates}\label{subsec:verification-of-templates}

ts api

\subsection{Code Generation}\label{subsec:code-generation}

generate ts and compile ts to js through ts api.

\section{Notes on Performance}\label{sec:notes-on-performance}

Very slow compiler/PP because of the chosen implementation, with tree traverser for every step.


\section{Testing}\label{sec:testing}

\subsection{Lexer and Parser}\label{subsec:testing-lexer-and-parser}

Tree-sitter tests are simple \codeword{.txt} files split up into three sections, the name of the test, the code that should be parsed, and the expected parse tree in S-expressions\cite{sexprs}.

\begin{code}{typescript}{Example of tree-sitter grammar test}{lst:tree-sitter-grammar-test}
    ===========================
    Closed template declaration
    ===========================

    template T {
        class A {
            i = 0;
        }
    }

    ---
    (program
        (template_declaration
            name: (identifier)
            body: (package_template_body
                    (class_declaration
                        name: (type_identifier)
                        body: (class_body
                            (public_field_definition
                                name: (property_identifier)
                                value: (number)))))))

\end{code}

\subsection{Transpiler}\label{subsec:testing-transpiler}

jest