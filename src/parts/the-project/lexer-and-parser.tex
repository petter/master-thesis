\subsection{The PTS Grammar}\label{subsec:the-pts-grammar}

PTS is an extension of TypeScript, and the grammar is also therefore an extension of the TypeScript grammar.
There is no published official TypeScript grammar (other than interpreting it from the implementation of the TypeScript compiler), however up until recently there used to be a TypeScript specification\cite{tsspec}.
This TypeScript specification was deprecated as it proved a to great a task to keep updated, with the ever-changing nature of the language.
However, most of the essential parts are still the same.
The PTS grammar is therefore based on the TypeScript specification, and on the ESTree Specification\cite{estreespec}.

In figure~\vref{fig:pts-grammar} we can see the PTS BNF grammar.
This is not the full grammar for PTS, as I have only included any additions or changes to the original TypeScript/JavaScript grammars.
More specifically the non-terminal $\bnfpn{declaration}$ is an extension of the original grammar, where we also include package and template declarations as legal declarations.
The productions for non-terminals $\bnfpn{id}$, $\bnfpn{class declaration}$, $\bnfpn{interface declaration}$, and $\bnfpn{class body}$ are also from the original grammar.



\begin{figure}
    \begin{bnf*}
        \bnfprod{declaration}
            { \bnfsk \bnfor \bnfpn{package declaration} \bnfor \bnfpn{template declaration} }\\
        \bnfprod{package declaration}
            { \bnfts{pack} \bnfsp \bnfpn{id} \bnfsp \bnfpn{PT body} }\\
        \bnfprod{template declaration}
            { \bnfts{template} \bnfsp \bnfpn{id} \bnfsp \bnfpn{PT body} }\\
        \bnfprod{PT body}
            { \bnfts{\{} \bnfsp \bnfpn{PT body decls} \bnfsp \bnfts{\}} }\\
        \bnfprod{PT body decls}
            { \bnfpn{PT body decls} \bnfsp \bnfpn{PT body decl} \bnfor \bnfes}\\
        \bnfprod{PT body decl}
            { \bnfpn{inst statement} \bnfor \bnfpn{addto statement} \bnfor }\\
        \bnfmore{ \bnfpn{class declaration} \bnfor \bnfpn{interface declaration} }\\
        \bnfprod{inst statement}
            { \bnfts{inst} \bnfsp \bnfpn{id} \bnfsp \bnfpn{inst rename block} }\\
        \bnfprod{inst rename block}
            { \bnfts{\{} \bnfsp \bnfpn{class renamings} \bnfsp \bnfts{\}} \bnfor \bnfes }\\
        \bnfprod{class renamings}
            { \bnfpn{class rename} \bnfor \bnfpn{class rename} \bnfts{,} \bnfsp \bnfpn{class renamings} }\\
        \bnfprod{class rename}
            { \bnfpn{rename} \bnfsp \bnfpn{field rename block} }\\
        \bnfprod{field rename block}
            { \bnfts{(} \bnfsp \bnfpn{field renamings} \bnfsp \bnfts{)} \bnfor \bnfes }\\
        \bnfprod{field renamings}
            { \bnfpn{rename} \bnfor \bnfpn{rename} \bnfts{,} \bnfsp \bnfpn{field renamings} }\\
        \bnfprod{rename}
            { \bnfpn{id} \bnfsp \bnfts{->} \bnfsp \bnfpn{id} }\\
        \bnfprod{addto statement}
            { \bnfts{addto} \bnfsp \bnfpn{id} \bnfsp \bnfpn{addto heritage} \bnfsp \bnfpn{class body} }\\
        \bnfprod{addto heritage}
            { \bnfpn{class heritage} \bnfor \bnfes }\\
    \end{bnf*}
    \caption{BNF grammar for PTS. The non-terminals $\bnfpn{declaration}$, $\bnfpn{id}$, $\bnfpn{class declaration}$, $\bnfpn{interface declaration}$, and $\bnfpn{class body}$ are productions from the TypeScript grammar.
    The ellipsis in the declaration production means that we extend the TypeScript production with some extra choices.}

    \textit{Legend:} Non-terminals are surrounded by $\bnfpn{angle brackets}$.
    Terminals are in $\bnfts{typewriter font}$.
    Meta-symbols are in regular font.
    \label{fig:pts-grammar}
\end{figure}


\subsection{Parser Generator}\label{subsec:parser-generator}

There are a lot of parser generators out there, but there is no one-size-fits-all solution.
In order to navigate through the sea of options we need to set some requirements in functionality, so that we can more easily find the right tool for the task.

TypeScript is a large language that is constantly updated, and is getting new features fairly often.
Because of this one of the requirements for our choice of parser generator is the possibility for extending grammars.
This is important because we don't want to be forced to rewrite the entire TypeScript grammar, as well as keeping it up-to-date.

Another desired attribute is a runtime library in TypeScript.
We will be working with the TypeScript API, which only


\subsubsection{ANTLR4}\label{subsubsec:antlr}

ANTLR, ANother Tool for Language Recognition, is a very powerful and versatile tool, used by many, such as Twitter for query parsing in their search engine\cite{Terence2012}.

ANTLR supports extending grammars, or more specifically importing them.
Importing a grammar works much like a "smart include".
It will include all rules that are not already defined in the grammar.
Through this you can extend a grammar with new rules or replacing them.
It does not however support extending rules, as in referencing the imported rule while overriding\cite{Terence2012}.
This isn't a major issue however as you could easily rewrite the rule with the additions.

The only supported runtime library in ANTLR is in Java.
This does not mean that you won't be able to use it in any other language, as you could simply invoke the runtime library through command line, however it is worth keeping in mind.

Overall ANTLR seems like a good option for our project, but the lack of a runtime library in TypeScript is a hurdle we would rather get a round if we can.

\subsubsection{GNU Bison}\label{subsubsec:bison}




\subsubsection{Tree-sitter}\label{subsubsec:tree-sitter}

Tree-sitter is mainly used in language servers and syntax highlighting, and I see no examples of it being used in the context of a compiler.
However, it does produce a parse tree, so I see no reason to why it would not work for our implementation.

For our implementation of the grammar I choose to go with \href{https://tree-sitter.github.io/tree-sitter/}{Tree-sitter}.

Because
\begin{itemize}
    \item Lets you extend grammars
    \item Has JavaScript/Node API
    \item Makes it possible to use the grammar for syntax highlighting
\end{itemize}


As we talked about in section~\vref{sec:what-do-we-need}, we set ourselves the goal to find an approach that would allow us to create an implementation that was loosely coupled with TypeScript.
While a fork of the TypeScript compiler or the Babel parser would not allow this, Tree-sitter on the other hand allows extending existing grammars.
Extending a grammar works much like extending a class in an object-oriented language.
A "sub grammar" inherits all the rules from the "super grammar", so an empty ruleset would effectively work the same as the super grammar.
Just like most object-oriented languages have access to the super class, we also have access to the super grammar in Tree-sitter.
All of this enables us to add, override, and extend rules in an existing grammar, all while staying loosely coupled with the super grammar.
By extending the grammar, and not forking it, we are able to simply update our dependency on the TypeScript grammar, minimizing the possibility for conflicts.

where we have the ability to override rules from the super grammar with our own rules.
Not only are we able to override rules, but we can combine the old rules with the new.

A good example of overriding and combining rules can be found in the grammar of PTS, see listing~\vref{lst:overriding-combining-rule}, where we override the \codeword{\_declaration} rule from the TypeScript grammar, to include the possibility for package and template declarations.

\begin{code}{javascript}{Snippet from the PTS grammar, where we override the \codeword{\_declaration} rule from the TypeScript grammar, and adding two additional declarations.}{lst:overriding-combining-rule}
    _declaration: ($, previous) =>
        choice(
            previous,
            $.template_declaration,
            $.package_declaration
        )
\end{code}


\subsection{Instantiation and Renaming}\label{subsec:instantiation-and-renaming}

\subsubsection{Scoping}\label{subsubsec:inst-scoping}

For creating scopes I chose the following node types for "making new scopes".

\begin{itemize}
    \item \codeword{class\_body}
    \item \codeword{statement\_block}
    \item \codeword{enum\_body}
    \item \codeword{if\_statement}
    \item \codeword{else\_statement}
    \item \codeword{for\_statement}
    \item \codeword{for\_in\_statement}
    \item \codeword{while\_statement}
    \item \codeword{do\_statement}
    \item \codeword{try\_statement}
    \item \codeword{with\_statement}
\end{itemize}

\subsubsection{Transforming Nodes to References}\label{subsubsec:transforming-nodes-to-references}

\subsection{Verification of Templates}\label{subsec:verification-of-templates}

ts api

\subsection{Code Generation}\label{subsec:code-generation}

generate ts and compile ts to js through ts api.