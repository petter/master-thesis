%! Author = Petter
%! Date = 9/22/2020

\chapter{Planning the project}\label{ch:planning-the-project}

\section{What Do We Need?}\label{sec:what-do-we-need}

\begin{itemize}
    \item The ability to add custom syntax (access to the tokenizer / parser)
    \item Some semantic analysis.
\end{itemize}

\section{Syntax}\label{sec:syntax}

For the implementation of PT we need syntax for the following:

\begin{itemize}
    \item Defining packages (\codeword{package} in PTj)
    \item Defining templates (\codeword{template} in PTj)
    \item Instantiating templates (\codeword{inst} in PTj)
    \item Renaming classes (\codeword{=>} in PTj)
    \item Renaming methods (\codeword{->} in PTj)
    \item Additions to classes (\codeword{addto} in PTj)
\end{itemize}

\codeword{template} and \codeword{inst} are both not in use nor reserved in the ECMAScript standard or in TypeScript, and can therefore be used in \plname{} without any issues.

The keyword \codeword{package} in TS / ES is as of yet not in use, however the ECMAScript standard has reserved it for future use.
In order to "future proof" our implementation we should avoid using this reserved keyword, as it could have some conflicts with a potential future implementation of packages in ECMAScript.
It could also be beneficial to not share the keyword in order avoid creating confusion between the future ES packages and PT Packages.
\codeword{module} is also a keyword that could be used to describe a PT package, however this is already used in the ES standard, and should therefore also be avoided for similar reasons to \codeword{package}, to avoid confusion.
We will therefore use (\codeword{pack} eller \codeword{bundle}? Må nok se litt mer på dette) instead. % TODO: find a proper name for package.

For renaming classes PTj uses \codeword{=>}, however in ES this is used in arrow-functions\cite{arrowfunction}.
To avoid confusion, and a potentially ambiguous grammar we will have to choose a different syntax for renaming classes.
PTj, for historical purposes, uses a different operator (\codeword{->}) for renaming class methods, however for keeping \plname{} simple we will stick to only having one common operator for renaming.

ECMAScript currently supports renaming of destructured fields using the \codeword{:}(colon) operator and aliasing imports using the keyword \codeword{as}.
Even though we opted to choose a different keyword for packages, we will here re-use the already existing \codeword{as} keyword for renaming as the concepts are so closely related.

\plname{}:
\begin{code}{typescript}{}{lst:pts-renaming}
    template T {
        class A {
            function f() : String {
                ...
            }
        }
    }

    pack P {
        inst T with A -> A (f -> g); // Function overloading not supported, so don't need to give signature.
        addto A {
            i : number = 0;
        }
    }
\end{code}

PTj:
\begin{code}{java}{}{lst:ptj-renaming}
    template T {
        class A {
            String f() {
                ...
            }
        }
    }

    package P {
        inst T with A => A (f() -> g()); 
        addto A {
            int i = 0;
        }
    }
\end{code}



\section{TypeScript vs JavaScript}\label{sec:typescript-vs-javascript}

\subsection{Verifying templates}\label{subsec:why-typescript-verifying-templates}

One of the requirements for PT is that each template should be verifiable.
There is no easy way to verify if some JavaScript code is verifiable without executing it.
With TypeScript on the other hand, with the language being statically typed, we can, at least to a much larger extent, verify if some piece of code is valid.
And thus we can also use this to validate each separate template in PT.

Now it should be noted that due to TypeScripts type system being unsound one could argue that this requirement of PT is not met.
While this is true it still outperforms JavaScript on this remark, and we will later in section\vref{subsec:pt-requirements-verifying-templates} discuss more in-depth to what extent this requirement is met.



\section{Choosing the right approach}\label{sec:choosing-the-right-approach}

Before jumping into a project of this magnitude it is important to find out what approach to use. 
The goal of this project is to extend TypeScript with the Package Templates language mechanism, this could be achieved by one of the following methods:

\begin{itemize}
    \item Making a fork of the TypeScript compiler
    \item Making a preprocessor for the TypeScript compiler
    \item Making a compiler plugin / transform
    \item Making a custom compiler from scratch
\end{itemize}


\subsection{Preprocessor for the TypeScript Compiler}\label{subsec:preprocessor-for-the-typescript-compiler}

More work than ex plugin / transformer.

\subsection{TypeScript Compiler Plugin / Transform}\label{subsec:typescript-compiler-plugin}

At the time of writing the official TypeScript compiler does not support compile time plugins.
The plugins for the TypeScript compiler is, as the TypeScript compiler wiki specifies, "for changing the editing experience only"\cite{tscplugin}.
However, there are alternatives that do enable compile time plugins / transformers;

\begin{itemize}
    \item ts-loader\cite{tsloadergithub}, for the webpack ecosystem
    \item Awesome Typescript Loader\cite{awesometypescriptloadergithub}, for the webpack ecosystem. Deprecated
    \item ts-node\cite{tsnodegithub}, REPL / runtime
    \item ttypescript\cite{ttypescriptgithub}, TypeScript tool TODO: Les mer på dette
\end{itemize}

Unfortunately ts-loader, Awesome Typescript Loader and ts-node does not support adding custom syntax, as it only transforms the AST produced by the TypeScript compiler.
Because of this they are not a viable option for our use-case and will therefore be discarded.

\subsection{Babel plugin}\label{subsec:babel-plugin}

Babel isn't strictly for TypeScript, but for JavaScript as a whole, however we could write our plugin to be dependent on the TypeScript transformation plugin.

Making a Babel plugin will make it very accessible as most web-projects use Babel, and the upkeep is cheap, as plugins are loosely coupled with the core.

In order for a Babel plugin to support custom syntax it has to provide a custom parser, a fork of the Babel parser.
Through this we can extend the TypeScript syntax with our syntax for PT.
This is all hidden away from the user, as this custom parser is a dependency of our Babel plugin.

Seeing as we have to make a fork of the parser in order to solve our problem, the upkeep will not be as cheap as first anticipated.
However, being able to have most of the logic loosely coupled with the compiler core it will still make it easier to keep updated than through a fork of the TypeScript compiler.

% TODO: Er det støttet å bruke flere plugins med forskjellige parsere?
% E.g. babel-plugin-typescript + vårt babel plugin?

\subsection{TypeScript Compiler Fork}\label{subsec:typescript-compiler-fork}

Possible, however not as accessible as other alternatives and will make upkeep expensive.

The TypeScript compiler is a monolith.
It has about 2.5 million lines of code, and therefore has a quite steep learning curve to get into.
If we were to go with this route it would be quite hard to keep up with the TypeScript updates, as updates to the compiler might break our implementation.
However, as we have seen, going the plugin / transform route also requires us to fork the underlying compiler and make changes to it, however with the majority of the implementation being loosely coupled it would still make it easier to keep up-to-date.
That being said it will probably be a lot easier to do semantic analysis in a fork of the TypeScript compiler vs in a plugin / transform.
