%! Author = Petter
%! Date = 9/22/2020

\chapter{Planning the project}\label{ch:planning-the-project}

\section{What Do We Need?}\label{sec:what-do-we-need}

\begin{itemize}
    \item The ability to add custom syntax (access to the tokenizer / parser)
    \item Some semantic analysis.
\end{itemize}

\section{Syntax}\label{sec:syntax}

For the implementation of PT we need some syntax for the following:

\begin{itemize}
    \item Defining packages (\codeword{package} in PTj)
    \item Defining templates (\codeword{template} in PTj)
    \item Instantiating templates (\codeword{inst} in PTj)
    \item Renaming classes (\codeword{=>} in PTj)
    \item Renaming methods (\codeword{->} in PTj)
\end{itemize}

\codeword{template} and \codeword{inst} are both not used or reserved in the ECMAScript standard or in TypeScript, and can therefore be used in \languagename without any issues.

The keyword \codeword{package} in TS / ES is as of yet not in use, however the ECMAScript standard has reserved it for future use.
In order to "future proof" our implementation we should avoid using this reserved keyword, as it could have some conflicts with a potential future implementation of packages in ECMAScript.
It could also be beneficial to not share the keyword in order to not create confusion between ES packages and PT Packages.
\codeword{module} is also a keyword that could be used to describe a PT package, however this is also reserved in the ES standard, and should therefore also be avoided for similar reasons to \codeword{package}, to avoid confusion.
We will therefore use (\codeword{pack} or \codeword{bundle}?) instead. % TODO: find a proper name for package.

For renaming classes PTj uses \codeword{=>}, however in ES this is used in arrow-functions\cite{arrowfunction}.
To avoid confusion and a potentially ambiguous grammar we will have to choose a different syntax for renaming classes.
PTj, for historical purposes, uses a different operator (\codeword{->}) for renaming class methods, however for keeping \languagename simple we will stick to only having one common operator for renaming.

ECMAScript currently supports renaming of destructured fields using the \codeword{:}(colon) operator and aliasing imports using the keyword \codeword{as}.
Even though we opted to choose a different keyword for packages, we will here re-use the already existing \codeword{as} keyword for renaming 

\input{parts/the-project/jsvssts.tex}

\section{Choosing the right approach}\label{sec:choosing-the-right-approach}

Before jumping into a project of this magnitude it is important to find out what approach to use. 
The end goal of this project is to extend TypeScript with the Package Templates language mechanism,
this can be achieved as following:

\begin{itemize}
    \item Making a fork of the TypeScript compiler
    \item Making a preprocessor for the TypeScript compiler
    \item Making a compiler plugin / transform
    \item Making a custom compiler from scratch
\end{itemize}

\subsection{TypeScript Compiler Fork}\label{subsec:typescript-compiler-fork}

Possible, however not as accessible as other alternatives and will make upkeep expensive.

\subsection{Preprocessor for the TypeScript Compiler}\label{subsec:preprocessor-for-the-typescript-compiler}

A lot more work than ex plugin / transformer.

\subsection{TypeScript Compiler Plugin / Transform}\label{subsec:typescript-compiler-plugin}

%Not possible at the time as the TypeScript compiler wiki specifies "TypeScript Language Service Plugins ("plugins") are for changing the editing experience only."\cite{tscplugin}.
%This might be possible in the future...

As of the time of writing this the official TypeScript compiler does not support compile time plugins. The plugins for the TypeScript compiler is, as the TypeScript compiler wiki specifies, "for changing the editing experience only"\cite{tscplugin}.
However there are alternatives that do enable compile time plugins / transformers;

\begin{itemize}
    \item ts-loader\cite{tsloadergithub}, for the webpack ecosystem
    \item Awesome Typescript Loader\cite{awesometypescriptloadergithub}, for the webpack ecosystem. Deprecated
    \item ts-node\cite{tsnodegithub}, REPL / runtime
    \item ttypescript\cite{ttypescriptgithub}, TypeScript tool TODO: Les mer p√• dette
    \item A compiler wrapper
\end{itemize}

Unfortunately most of these don't support custom syntax, which is one of the requirements we have in order to properly implement PT.


\subsection{Babel plugin}\label{subsec:babel-plugin}

Babel isn't strictly for TypeScript, but for JavaScript as a whole.
Will however make it very accessible as most web-projects use Babel, and the upkeep is cheap, as plugins are pretty independent from the core.

Saying that this is strictly a Babel plugin wouldn't be entirely true, as we would have to fork the Babel parser in order to include our custom syntax\cite{babelparserdocs}.
However this is all hidden away from the user, as this custom parser is a dependency of our Babel plugin.

Babel Plugin is not as nice as I first thought, it seems to be pretty hard to write third-party plugins as you have to make a parser fork for custom syntax, and there is a severe lack of documentation.
Most examples of Babel plugins mostly use internal helpers and utils, which are hard to use for third-party plugins.

TODO: Does it support having multiple custom parser?
E.g. babel-plugin-typescript + our custom babel plugin?
