%! Author = petter
%! Date = 04.01.2021

\chapter{Difference between PTS and PTj}\label{ch:difference-between-pts-and-ptj}


\section{Nominal vs. Structural Typing}\label{sec:nominal-vs-structural-typing}

Much taken from TAPL.

Nominal and structural are two major categories of type systems.
Nominal type systems are the norm in mainstream PLs, while in research literature is for the most part concerned with structural typing.

Write about pros and cons of both nominal and structural typing

nominal pros:
Trivial to check if a type is a subtype of another
Natural and intuitive recursive types (Structural typing also has recursive types, check if java and typescript support it).
    Recursive types are types that mention itself, like in lists and trees.
    They are just as easy to use in structural languages, however for calculi such as proofs recursive types come for free in nominal type systems while it is a bit more of a hassle in structurally typed systems, especially with mutually recursive types.

\begin{lstlisting}[label={lst:ts-recursive-type}, language=TypeScript]
    // Simple recursive type
    interface BinTree<T> {
        data: T;
        children: [BinTree<T>, BinTree<T>];
    }

    // Cyclic recursive type
    interface A {
        b : B;
    }

    interface B {
        a: A;
    }
\end{lstlisting}

\begin{lstlisting}[label={lst:java-recursive-type}, language=Java]
    interface BinTree<T> {
        T getData();
        Pair<BinTree<T>, BinTree<T>> getChildren();
    }
\end{lstlisting}

Often runtime-objects are tagged with the types, which are useful for multiple things like doing runtime instanceof checks. (This can also be used in structural typing)
It is "easier" to check sub-type relations in nominal type systems, even though you will still have to do a structural comparison, you only have to do this calculation once per type.
    Even though it is easier to achieve better performance for nominal vs structural types, it is still possible to achieve close to if not equal performance in structural type systems, through some representation techniques(Consider finding a article on this).
A questionable advantage for nominal typing is that they prevent "spurious subsumption", that is using a structurally equal type in a place where it should not be used.
    I would argue that there are more cases where this is a compromise than a benefit, and there are better ways to prevent this from happening, such as single-constructor datatypes or ADTs.

nominal cons:

structural pros:
Structural types are "tidier and more elegant".
    They carry all the information to understand the meaning of the type.
    In nominal systems we are working with some global collection of names, which can make it hard to understand some types.


structural cons:


\subsection{What is nominal typing?}\label{subsec:what-is-nominal-typing?}



\begin{lstlisting}[label={lst:nominal-typing-example}, language=Java]
    // Given the following class definitions for A, B and C:
    class A {
        void f() {
            ...
        }
    }

    class B extends A {
        ...
    }

    class C {
        void f() {
            ...
        }
    }

    // And a consumer with the following type:
    void g(A a) { ... }

    // Would result in the following
    g(new A()); // Ok
    g(new B()); // Ok
    g(new C()); // Error, C not of type A
\end{lstlisting}

\subsection{What is structural typing?}\label{subsec:what-is-structural-typing?}

\begin{lstlisting}[label={lst:structural-typing-example2}, language=Java]
    // Given the same class definitions and the same consumer as in the example above.
    // Would result in the following
    g(new A()); // Ok
    g(new B()); // Ok
    g(new C()); // Ok, because C is structurally equal to A
\end{lstlisting}

\subsection{Which Better Fits PT?}\label{subsec:which-better-fits-pt?}

In PTj there are elements of structural typing for the implementation of required types.
This is because PT doesn't allow externally declared classes, interfaces, etc., so in order to be able to have constraints on generic types structural typing was needed.
I would therefore argue that a structurally typed language is a better fit for PT, because Ockhams razor / keeping it tidier.

